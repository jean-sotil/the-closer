{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize TypeScript Project with Strict Configuration",
        "description": "Set up the foundational TypeScript project structure with strict type checking, path aliases, and monorepo configuration using the defined repository structure.",
        "details": "1. Initialize npm/pnpm workspace with package.json\n2. Create tsconfig.json with strict: true, noImplicitAny: true, strictNullChecks: true\n3. Configure path aliases (@shared/*, @mcp-servers/*, @lead-discovery/*, etc.)\n4. Set up ESLint with TypeScript parser and recommended rules\n5. Configure Prettier for consistent code formatting\n6. Create the full directory structure as specified:\n   - src/shared/, src/mcp-servers/, src/lead-discovery/, src/audit-engine/\n   - src/data-layer/, src/email-automation/, src/dashboard/\n   - tests/unit/, tests/integration/, tests/e2e/\n7. Add .gitignore, .env.example with all required environment variables\n8. Install base dependencies: typescript, @types/node, dotenv, zod",
        "testStrategy": "Verify tsconfig.json compiles without errors. Run `tsc --noEmit` to validate configuration. Ensure all path aliases resolve correctly in a test import.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize pnpm workspace and root package.json",
            "description": "Set up the pnpm workspace configuration with package.json containing all base dependencies and workspace settings for the monorepo structure.",
            "dependencies": [],
            "details": "1. Initialize pnpm workspace with `pnpm init`\n2. Create pnpm-workspace.yaml with workspace packages: ['src/*']\n3. Configure root package.json with:\n   - name: 'the-closer-webapp'\n   - private: true\n   - type: 'module'\n   - engines: { node: '>=18.0.0', pnpm: '>=8.0.0' }\n   - scripts: build, lint, format, typecheck\n4. Install base dependencies:\n   - typescript@5.x, @types/node@20.x\n   - dotenv, zod for config validation\n5. Install dev dependencies:\n   - eslint, @typescript-eslint/parser, @typescript-eslint/eslint-plugin\n   - prettier, eslint-config-prettier\n6. Create .npmrc with strict-peer-dependencies=true, auto-install-peers=true",
            "status": "done",
            "testStrategy": "Run `pnpm install` to verify workspace resolves. Check package.json has correct structure with `cat package.json`. Verify pnpm-workspace.yaml creates valid workspace with `pnpm ls`.",
            "parentId": "undefined",
            "updatedAt": "2026-01-30T22:17:17.058Z"
          },
          {
            "id": 2,
            "title": "Configure TypeScript with strict settings and path aliases",
            "description": "Create tsconfig.json with strict type checking enabled and configure path aliases for all source directories to enable clean imports across the monorepo.",
            "dependencies": [
              1
            ],
            "details": "1. Create tsconfig.json with compiler options:\n   - target: 'ES2022', module: 'NodeNext', moduleResolution: 'NodeNext'\n   - strict: true, noImplicitAny: true, strictNullChecks: true\n   - strictFunctionTypes: true, strictBindCallApply: true\n   - noUnusedLocals: true, noUnusedParameters: true\n   - exactOptionalPropertyTypes: true, noUncheckedIndexedAccess: true\n   - esModuleInterop: true, skipLibCheck: true\n   - declaration: true, declarationMap: true, sourceMap: true\n   - outDir: './dist', rootDir: './src'\n2. Configure path aliases in paths:\n   - '@shared/*': ['src/shared/*']\n   - '@mcp-servers/*': ['src/mcp-servers/*']\n   - '@lead-discovery/*': ['src/lead-discovery/*']\n   - '@audit-engine/*': ['src/audit-engine/*']\n   - '@data-layer/*': ['src/data-layer/*']\n   - '@email-automation/*': ['src/email-automation/*']\n   - '@dashboard/*': ['src/dashboard/*']\n3. Set include: ['src/**/*'], exclude: ['node_modules', 'dist', 'tests']",
            "status": "done",
            "testStrategy": "Run `pnpm tsc --noEmit` to validate configuration compiles without errors. Create a test file importing from path alias and verify it resolves. Check `tsc --showConfig` outputs expected settings.",
            "parentId": "undefined",
            "updatedAt": "2026-01-30T22:17:37.648Z"
          },
          {
            "id": 3,
            "title": "Set up ESLint and Prettier configurations",
            "description": "Configure ESLint with TypeScript parser and strict rules, and set up Prettier for consistent code formatting across the entire codebase.",
            "dependencies": [
              1
            ],
            "details": "1. Create eslint.config.js (flat config format):\n   - Use @typescript-eslint/parser\n   - Enable @typescript-eslint/eslint-plugin recommended rules\n   - Configure rules: no-unused-vars (error), no-explicit-any (warn)\n   - Add TypeScript-specific rules: explicit-function-return-type, no-floating-promises\n   - Configure ignores: ['dist/', 'node_modules/', '*.js']\n2. Create .prettierrc.json:\n   - semi: true, singleQuote: true, trailingComma: 'es5'\n   - tabWidth: 2, printWidth: 100\n   - bracketSpacing: true, arrowParens: 'always'\n3. Create .prettierignore:\n   - dist/, node_modules/, *.md, pnpm-lock.yaml\n4. Add scripts to package.json:\n   - lint: 'eslint src/ --ext .ts,.tsx'\n   - lint:fix: 'eslint src/ --ext .ts,.tsx --fix'\n   - format: 'prettier --write src/'\n   - format:check: 'prettier --check src/'",
            "status": "done",
            "testStrategy": "Run `pnpm lint` on sample TypeScript file to verify rules apply. Run `pnpm format:check` to verify Prettier works. Test that lint:fix auto-corrects fixable issues.",
            "parentId": "undefined",
            "updatedAt": "2026-01-30T22:17:58.247Z"
          },
          {
            "id": 4,
            "title": "Create complete directory structure for all modules",
            "description": "Establish the full directory hierarchy for source code, tests, and configuration as specified in the architecture, including placeholder index files for each module.",
            "dependencies": [
              1
            ],
            "details": "1. Create source directories:\n   - src/shared/ (types/, config/, errors/, utils/)\n   - src/mcp-servers/ (puppeteer/, supabase/, mailgun/, calendar/)\n   - src/lead-discovery/ (google-maps/, network-interceptor/, data-extractor/)\n   - src/audit-engine/ (visual-qa/, performance/, accessibility/, evidence/)\n   - src/data-layer/ (repositories/, migrations/, seeds/)\n   - src/email-automation/ (templates/, campaigns/, scheduler/)\n   - src/dashboard/ (components/, hooks/, pages/, services/)\n2. Create test directories:\n   - tests/unit/ (shared/, lead-discovery/, audit-engine/, data-layer/, email-automation/)\n   - tests/integration/ (mcp-servers/, workflows/)\n   - tests/e2e/ (scenarios/, fixtures/)\n3. Create placeholder index.ts in each source directory exporting empty object\n4. Create tests/setup.ts for test configuration\n5. Ensure .gitkeep files in empty directories to preserve structure",
            "status": "done",
            "testStrategy": "Verify all directories exist with `find src -type d`. Check each module has index.ts with `ls src/*/index.ts`. Run `tsc --noEmit` to ensure placeholder files compile.",
            "parentId": "undefined",
            "updatedAt": "2026-01-30T22:20:22.291Z"
          },
          {
            "id": 5,
            "title": "Create environment configuration and Git setup files",
            "description": "Set up .env.example with all required environment variables documented, create comprehensive .gitignore, and add project README with setup instructions.",
            "dependencies": [
              1
            ],
            "details": "1. Create .env.example with all required variables:\n   - # Supabase Configuration\n   - SUPABASE_URL=https://xxx.supabase.co\n   - SUPABASE_ANON_KEY=your_anon_key\n   - SUPABASE_SERVICE_KEY=your_service_key\n   - # Mailgun Configuration\n   - MAILGUN_API_KEY=your_api_key\n   - MAILGUN_DOMAIN=mg.yourdomain.com\n   - # Google Calendar\n   - GOOGLE_CLIENT_ID=your_client_id\n   - GOOGLE_CLIENT_SECRET=your_client_secret\n   - GOOGLE_REFRESH_TOKEN=your_refresh_token\n   - # VAPI Voice AI (Phase 3)\n   - VAPI_API_KEY=your_vapi_key\n   - # Browserbase (Optional)\n   - BROWSERBASE_API_KEY=your_browserbase_key\n   - BROWSERBASE_PROJECT_ID=your_project_id\n   - # Environment\n   - NODE_ENV=development\n2. Create .gitignore:\n   - node_modules/, dist/, .env, .env.local, *.log\n   - .DS_Store, coverage/, .turbo/, .cache/\n3. Copy .env.example to .env for local development template",
            "status": "in-progress",
            "testStrategy": "Verify .env.example contains all documented variables. Check .gitignore prevents .env from being tracked with `git status`. Validate environment loading works by creating test .env and running node script.",
            "parentId": "undefined",
            "updatedAt": "2026-01-30T22:20:23.599Z"
          }
        ],
        "updatedAt": "2026-01-30T22:27:39.161Z",
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down into detailed configuration steps for each tool (pnpm, tsconfig, ESLint, Prettier) with verification commands."
      },
      {
        "id": "2",
        "title": "Define Core TypeScript Interfaces and Types",
        "description": "Create comprehensive TypeScript interfaces for LeadProfile, AuditResult, CampaignConfig, and all supporting types as specified in the architecture.",
        "details": "Create src/shared/types/ with:\n1. lead.ts:\n   - LeadProfile interface (id, business_name, address, phone, website_url, rating, review_count, category, search_query, qualification_score, qualification_reasons, status, timestamps)\n   - LeadStatus enum (PENDING, CONTACTED, RESPONDED, BOOKED, DISQUALIFIED)\n   - LeadFilters interface for search criteria\n2. audit.ts:\n   - AuditResult interface (id, lead_id, url, performance_score, fcp, lcp, cls, unused_code_percent, accessibility_score, wcag_violations, evidence_urls, responsive_issues, timestamps)\n   - WCAGViolation interface (rule_id, severity, description, element_selector, recommendation)\n   - ResponsiveIssue interface\n   - PerformanceMetrics interface\n3. campaign.ts:\n   - CampaignConfig interface (id, name, template_id, lead_filters, sequence, status, timestamps)\n   - EmailSequenceStep interface (step_number, delay_days, template_id, send_condition)\n   - EmailTemplate interface\n4. Export all from src/shared/types/index.ts",
        "testStrategy": "Create type tests using tsd or typescript-test to verify interface contracts. Ensure all required fields are enforced and optional fields allow undefined.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create lead.ts with LeadProfile interface and LeadStatus enum",
            "description": "Define the core LeadProfile interface with all business data fields and the LeadStatus enum for tracking lead progression through the sales pipeline.",
            "dependencies": [],
            "details": "Create src/shared/types/lead.ts with:\n- LeadProfile interface containing: id (UUID string), business_name (string), address (string | null), phone_number (string | null), website_url (string | null), rating (number | null), review_count (number | null), business_category (string | null), source_query (string), qualification_score (number), qualification_reasons (string[]), status (LeadStatus), discovered_at (Date), updated_at (Date), last_contacted_at (Date | null), next_followup_at (Date | null), notes (string | null)\n- LeadStatus enum with values: PENDING, CONTACTED, RESPONDED, BOOKED, CONVERTED, DECLINED, DISQUALIFIED\n- LeadFilters interface for search/filter operations containing: status (LeadStatus[]), minRating (number), maxRating (number), category (string), hasWebsite (boolean), minQualificationScore (number), searchQuery (string), discoveredAfter (Date), discoveredBefore (Date)\n- Export all types",
            "status": "pending",
            "testStrategy": "Create type tests using tsd to verify LeadProfile requires all mandatory fields. Test that LeadStatus enum values are correct. Verify LeadFilters allows partial filter combinations.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create audit.ts with AuditResult and supporting interfaces",
            "description": "Define comprehensive audit-related types including AuditResult, WCAGViolation, ResponsiveIssue, and PerformanceMetrics interfaces for storing site analysis data.",
            "dependencies": [
              1
            ],
            "details": "Create src/shared/types/audit.ts with:\n- PerformanceMetrics interface: fcp (number, First Contentful Paint ms), lcp (number, Largest Contentful Paint ms), cls (number, Cumulative Layout Shift), tti (number, Time to Interactive ms), tbt (number, Total Blocking Time ms), speedIndex (number)\n- WCAGViolation interface: rule_id (string), severity ('critical' | 'serious' | 'moderate' | 'minor'), description (string), element_selector (string | null), recommendation (string), help_url (string | null)\n- ResponsiveIssue interface: viewport (string), issue_type ('horizontal_overflow' | 'touch_target_too_small' | 'text_too_small' | 'layout_shift'), description (string), element_selector (string | null), screenshot_url (string | null)\n- EvidenceUrl interface: type ('screenshot' | 'video' | 'report'), url (string), created_at (Date), expires_at (Date | null)\n- AuditResult interface: id (string), lead_id (string), url (string), performance_score (number 0-100), performance_metrics (PerformanceMetrics), unused_js_percent (number), unused_css_percent (number), accessibility_score (number 0-100), wcag_violations (WCAGViolation[]), responsive_issues (ResponsiveIssue[]), mobile_friendly (boolean), evidence_urls (EvidenceUrl[]), audited_at (Date), audit_duration_ms (number)\n- Export all types",
            "status": "pending",
            "testStrategy": "Verify AuditResult requires lead_id reference. Test that severity union type only accepts valid values. Ensure PerformanceMetrics numeric fields accept valid ranges.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create campaign.ts with CampaignConfig and email sequence types",
            "description": "Define campaign management types including CampaignConfig, EmailSequenceStep, EmailTemplate, and CampaignStatus for orchestrating outreach automation.",
            "dependencies": [
              1
            ],
            "details": "Create src/shared/types/campaign.ts with:\n- CampaignStatus enum: DRAFT, ACTIVE, PAUSED, COMPLETED, ARCHIVED\n- SendCondition type: 'always' | 'if_no_response' | 'if_opened' | 'if_clicked'\n- EmailTemplate interface: id (string), name (string), subject (string), body_html (string), body_text (string), variables (string[], e.g. ['business_name', 'specific_issue', 'evidence_link']), created_at (Date), updated_at (Date)\n- EmailSequenceStep interface: step_number (number), delay_days (number), template_id (string), send_condition (SendCondition), max_sends (number | null)\n- CampaignConfig interface: id (string), name (string), description (string | null), template_id (string), lead_filters (LeadFilters from lead.ts), sequence (EmailSequenceStep[]), status (CampaignStatus), created_at (Date), updated_at (Date), started_at (Date | null), completed_at (Date | null)\n- OutreachRecord interface: id (string), campaign_id (string), lead_id (string), step_number (number), status ('pending' | 'sent' | 'delivered' | 'opened' | 'clicked' | 'bounced' | 'failed'), sent_at (Date | null), opened_at (Date | null), clicked_at (Date | null)\n- Import LeadFilters from ./lead\n- Export all types",
            "status": "pending",
            "testStrategy": "Verify CampaignConfig correctly references LeadFilters type. Test EmailSequenceStep requires all mandatory fields. Ensure SendCondition union type is properly constrained.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create shared utility types and PainPoint interface",
            "description": "Define common utility types used across modules including PainPoint for audit findings, generic API response wrappers, and pagination types.",
            "dependencies": [],
            "details": "Create src/shared/types/common.ts with:\n- PainPointSeverity type: 'critical' | 'high' | 'medium' | 'low'\n- PainPointType type: 'SLOW_LOAD' | 'UNUSED_JS' | 'UNUSED_CSS' | 'WCAG_VIOLATION' | 'BROKEN_MOBILE_UX' | 'MISSING_META' | 'NO_SSL' | 'BROKEN_LINKS'\n- PainPoint interface: type (PainPointType), value (string, e.g. '6.2s'), severity (PainPointSeverity), description (string), evidence_url (string | null)\n- ApiResponse<T> generic interface: success (boolean), data (T | null), error (ApiError | null), timestamp (Date)\n- ApiError interface: code (string), message (string), details (Record<string, unknown> | null)\n- PaginatedResponse<T> interface: items (T[]), total (number), page (number), pageSize (number), hasMore (boolean)\n- PaginationParams interface: page (number), pageSize (number), sortBy (string | null), sortOrder ('asc' | 'desc')\n- Timestamps interface (reusable): created_at (Date), updated_at (Date)\n- Export all types",
            "status": "pending",
            "testStrategy": "Test generic types work with various concrete types. Verify PainPoint severity and type unions are correctly constrained. Ensure ApiResponse handles both success and error cases.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create barrel export index.ts and validate type integration",
            "description": "Create the main index.ts barrel file that exports all types and validate that all interfaces integrate correctly with proper cross-references.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create src/shared/types/index.ts with:\n- Re-export all types from ./lead: export * from './lead'\n- Re-export all types from ./audit: export * from './audit'\n- Re-export all types from ./campaign: export * from './campaign'\n- Re-export all types from ./common: export * from './common'\n- Add JSDoc comments for each export group describing the module purpose\n- Create a LeadWithAudit composite type combining LeadProfile with optional AuditResult[]\n- Create a CampaignWithStats interface extending CampaignConfig with: total_leads (number), sent_count (number), open_rate (number), response_rate (number), booked_count (number)\n- Validate all cross-module type references work (CampaignConfig references LeadFilters, AuditResult references lead_id, etc.)\n- Ensure no circular dependencies exist between type files",
            "status": "pending",
            "testStrategy": "Verify all exports are accessible from index.ts. Test that composite types correctly extend base types. Run tsc --noEmit to ensure no type errors. Test imports work from @shared/types path alias.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create separate files for each domain (lead, audit, campaign) with comprehensive JSDoc and type validation tests.",
        "updatedAt": "2026-01-30T22:31:38.377Z"
      },
      {
        "id": "3",
        "title": "Implement Configuration Management System",
        "description": "Build environment variable management with runtime validation, supporting all required API keys and service configurations.",
        "details": "Create src/shared/config/:\n1. environment.ts:\n   - Load environment variables using dotenv\n   - Define AppConfig interface with all env vars:\n     * SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY\n     * MAILGUN_API_KEY, MAILGUN_DOMAIN\n     * GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REFRESH_TOKEN\n     * VAPI_API_KEY (optional Phase 3)\n     * BROWSERBASE_API_KEY, BROWSERBASE_PROJECT_ID (optional)\n   - Validate required variables on startup using Zod\n   - Throw descriptive error if required vars missing\n2. constants.ts:\n   - Rate limiting constants (MAPS_REQUEST_DELAY_MS: 2000)\n   - Lighthouse thresholds (PERFORMANCE_SCORE_THRESHOLD: 50)\n   - Qualification thresholds (MIN_RATING: 4.0)\n   - Email sequence defaults\n3. Export getConfig() function that returns validated AppConfig",
        "testStrategy": "Unit tests for config loading with valid/invalid/missing values. Test that appropriate errors thrown for missing required vars. Test default values applied for optional vars.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Configuration Directory Structure and TypeScript Types",
            "description": "Set up the src/shared/config directory and define TypeScript interfaces for the AppConfig and related types.",
            "dependencies": [],
            "details": "Create src/shared/config/ directory structure. Define AppConfig interface with all environment variables including: SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY (required); MAILGUN_API_KEY, MAILGUN_DOMAIN (required); GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REFRESH_TOKEN (required); VAPI_API_KEY (optional); BROWSERBASE_API_KEY, BROWSERBASE_PROJECT_ID (optional). Create separate types for required vs optional config sections.",
            "status": "pending",
            "testStrategy": "Verify TypeScript types compile correctly. Test that interface exports are accessible from other modules.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Zod Schema for Environment Validation",
            "description": "Create Zod validation schemas that enforce required fields and proper formats for all environment variables.",
            "dependencies": [
              1
            ],
            "details": "In src/shared/config/environment.ts, create Zod schemas: envSchema for required variables with .string().min(1) constraints for SUPABASE_URL (url format), SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY, MAILGUN_API_KEY, MAILGUN_DOMAIN, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REFRESH_TOKEN. Add optional schema for VAPI_API_KEY, BROWSERBASE_API_KEY, BROWSERBASE_PROJECT_ID with .optional() modifier. Use z.object() to combine schemas.",
            "status": "pending",
            "testStrategy": "Unit tests with mock environment variables. Test valid configs pass validation. Test missing required vars throw ZodError with descriptive messages.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Environment Loading with dotenv Integration",
            "description": "Create the environment loading logic using dotenv to parse .env files and integrate with Zod validation.",
            "dependencies": [
              2
            ],
            "details": "Install dotenv package. In environment.ts, implement loadEnvironment() function: call dotenv.config() to load .env file, extract relevant process.env values into an object, pass to Zod schema.safeParse(), if validation fails throw descriptive Error listing all missing/invalid fields with their issues, if valid return typed AppConfig object. Handle .env file not found gracefully (allow pure env vars).",
            "status": "pending",
            "testStrategy": "Test loading from actual .env file. Test loading from process.env without file. Test comprehensive error messages when validation fails.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Constants Module with Rate Limits and Thresholds",
            "description": "Implement constants.ts with all rate limiting, scoring thresholds, and default configuration values.",
            "dependencies": [
              1
            ],
            "details": "Create src/shared/config/constants.ts with exported constants: Rate limiting - MAPS_REQUEST_DELAY_MS: 2000, EMAIL_SEND_DELAY_MS: 1000, MAX_CONCURRENT_AUDITS: 10. Lighthouse thresholds - PERFORMANCE_SCORE_THRESHOLD: 50, ACCESSIBILITY_SCORE_THRESHOLD: 50, MOBILE_FRIENDLY_THRESHOLD: 90. Qualification - MIN_RATING: 4.0, MIN_REVIEW_COUNT: 5. Email defaults - MAX_FOLLOW_UPS: 3, FOLLOW_UP_DELAY_DAYS: [2, 5, 10].",
            "status": "pending",
            "testStrategy": "Verify constants are exported and have correct values. Test constants are frozen/immutable if using Object.freeze.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement getConfig Singleton and Module Exports",
            "description": "Create the getConfig() function as a singleton accessor and set up proper module exports with an index.ts barrel file.",
            "dependencies": [
              3,
              4
            ],
            "details": "In environment.ts, implement getConfig(): create module-level _config variable initialized to null, on first call run loadEnvironment() and cache result, on subsequent calls return cached config. Add configLoaded() helper to check if initialized. Create src/shared/config/index.ts barrel file exporting: getConfig, configLoaded, AppConfig type, all constants from constants.ts. Ensure tree-shaking friendly exports.",
            "status": "pending",
            "testStrategy": "Test getConfig returns same instance on multiple calls (singleton). Test exports are accessible via barrel file. Test configLoaded reflects actual state.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail Zod schema creation, singleton pattern implementation, and comprehensive error message generation for each config section.",
        "updatedAt": "2026-01-30T22:34:49.705Z"
      },
      {
        "id": "4",
        "title": "Create Error Handling Utilities and Base Error Classes",
        "description": "Implement custom error classes for all error scenarios with proper typing, stack traces, and error codes for consistent error handling across the application.",
        "details": "Create src/shared/errors/:\n1. base-error.ts:\n   - AppError base class extending Error\n   - Properties: code (string), statusCode (number), isOperational (boolean)\n   - Proper stack trace capture using Error.captureStackTrace\n2. Specific error classes:\n   - ValidationError (code: VALIDATION_ERROR, statusCode: 400)\n   - NotFoundError (code: NOT_FOUND, statusCode: 404)\n   - RateLimitError (code: RATE_LIMIT, statusCode: 429)\n   - MCPConnectionError (code: MCP_CONNECTION_ERROR, statusCode: 503)\n   - AuditFailedError (code: AUDIT_FAILED, statusCode: 500)\n   - EmailDeliveryError (code: EMAIL_DELIVERY_FAILED, statusCode: 502)\n3. handlers.ts:\n   - Global error handler function for async operations\n   - Error logging utility with structured output\n   - Error serialization for API responses",
        "testStrategy": "Unit tests verify error message formatting, stack traces, and error codes. Test error handler catches and formats errors correctly. Test serialization produces valid JSON.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement AppError Base Class with Stack Trace Capture",
            "description": "Create the foundational AppError base class that extends the native Error class with custom properties for error code, HTTP status code, and operational flag.",
            "dependencies": [],
            "details": "Create src/shared/errors/base-error.ts with AppError class extending Error. Include properties: code (string for error identification), statusCode (number for HTTP responses), isOperational (boolean to distinguish operational vs programmer errors). Implement proper stack trace capture using Error.captureStackTrace(this, this.constructor) in the constructor. Add a toJSON() method for serialization. Export the class and any shared error code constants.",
            "status": "pending",
            "testStrategy": "Unit tests verify AppError instantiation with all properties set correctly. Test stack trace is captured and excludes constructor frame. Test toJSON() produces expected object structure. Test inheritance chain is correct (instanceof Error returns true).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create HTTP Client Error Classes (400-level errors)",
            "description": "Implement specific error classes for client-side errors including ValidationError (400), NotFoundError (404), and RateLimitError (429).",
            "dependencies": [
              1
            ],
            "details": "Create src/shared/errors/client-errors.ts with three classes extending AppError: ValidationError with code 'VALIDATION_ERROR' and statusCode 400, accepting optional field-level validation details; NotFoundError with code 'NOT_FOUND' and statusCode 404, accepting resource type and identifier; RateLimitError with code 'RATE_LIMIT' and statusCode 429, accepting retryAfter timestamp. Each class should have meaningful default messages and accept custom messages.",
            "status": "pending",
            "testStrategy": "Unit tests verify each error class has correct code and statusCode. Test custom messages override defaults. Test ValidationError includes field details in serialization. Test RateLimitError includes retryAfter in response.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Service Error Classes (500-level errors)",
            "description": "Implement specific error classes for server-side and service errors including MCPConnectionError (503), AuditFailedError (500), and EmailDeliveryError (502).",
            "dependencies": [
              1
            ],
            "details": "Create src/shared/errors/service-errors.ts with three classes extending AppError: MCPConnectionError with code 'MCP_CONNECTION_ERROR' and statusCode 503, accepting server name and connection details; AuditFailedError with code 'AUDIT_FAILED' and statusCode 500, accepting audit type and target URL; EmailDeliveryError with code 'EMAIL_DELIVERY_FAILED' and statusCode 502, accepting recipient and provider error details. Include cause property for wrapping underlying errors.",
            "status": "pending",
            "testStrategy": "Unit tests verify each error class has correct code and statusCode. Test cause chaining preserves original error. Test service-specific details are captured. Test isOperational flag is set appropriately (false for programmer errors).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Global Error Handler and Async Wrapper",
            "description": "Create utility functions for handling errors in async operations and a global error handler for consistent error processing.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create src/shared/errors/handlers.ts with: asyncHandler wrapper function that catches Promise rejections and forwards to error handler; globalErrorHandler function that determines if error is AppError or unknown, logs appropriately, and returns standardized error response; handleAsync utility for wrapping async route handlers. Include error type guards (isAppError, isOperationalError) for type-safe error checking.",
            "status": "pending",
            "testStrategy": "Unit tests verify asyncHandler catches and forwards errors. Test globalErrorHandler distinguishes AppError from generic errors. Test unknown errors are wrapped with 500 status. Test type guards correctly identify error types.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Error Logging and Serialization Utilities",
            "description": "Implement structured error logging utility and serialization functions for API responses with proper sensitive data handling.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create src/shared/errors/logging.ts with: logError function that outputs structured JSON logs with timestamp, error code, message, stack trace (in development), and request context; serializeError function that converts AppError to safe API response format (excludes stack in production, includes error code and user-friendly message); createErrorResponse helper that builds consistent HTTP error response body. Add index.ts barrel file exporting all error classes and utilities from src/shared/errors/.",
            "status": "pending",
            "testStrategy": "Unit tests verify log output format is valid JSON with required fields. Test stack traces excluded in production mode. Test serialization removes sensitive details. Test barrel exports all classes and utilities correctly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Document each error type's usage scenarios and create comprehensive error mapping from external APIs.",
        "updatedAt": "2026-01-30T22:54:14.744Z"
      },
      {
        "id": "5",
        "title": "Implement Zod Validation Schemas",
        "description": "Create comprehensive Zod schemas for all data structures to ensure runtime type safety at system boundaries.",
        "details": "Create src/shared/validation/schemas.ts:\n1. Lead validation:\n   - leadProfileSchema: Validate all LeadProfile fields with proper types\n   - Phone number normalization transform\n   - URL validation for website_url\n   - Rating validation (1-5 range)\n2. Audit validation:\n   - auditResultSchema: Validate all AuditResult fields\n   - Score validations (0-100 range)\n   - WCAG violation severity enum\n3. Campaign validation:\n   - campaignConfigSchema: Validate campaign settings\n   - Email sequence validation (step order, delays)\n4. Search criteria validation:\n   - searchCriteriaSchema: location, category, radius, rating filters\n5. Create validation utility functions:\n   - validateLeadProfile(data: unknown): LeadProfile\n   - validateAuditResult(data: unknown): AuditResult\n   - Throw ValidationError with detailed field errors on failure",
        "testStrategy": "Comprehensive unit tests with valid inputs (pass), invalid inputs (fail with specific errors), edge cases (boundary values, empty strings, null vs undefined).",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create validation directory structure and base Zod schema utilities",
            "description": "Set up the src/shared/validation directory and create foundational Zod utilities including custom error formatting and reusable validation primitives.",
            "dependencies": [],
            "details": "Create src/shared/validation/ directory structure. Create schemas.ts as the main file. Import Zod and define reusable primitive schemas: phoneSchema with regex pattern for US phone numbers (e.g., /^\\+?1?[2-9]\\d{2}[2-9]\\d{6}$/), urlSchema using z.string().url() with optional https:// prefix handling, ratingSchema using z.number().min(1).max(5), scoreSchema using z.number().min(0).max(100). Create ValidationError custom error class that extends AppError from src/shared/errors with detailed field-level error information. Export formatZodError utility function that converts ZodError to ValidationError with readable field paths.",
            "status": "pending",
            "testStrategy": "Unit tests verify primitive schemas accept valid inputs and reject invalid ones. Test phoneSchema with various formats (with/without country code, dashes, spaces). Test urlSchema handles http/https and invalid URLs. Test formatZodError produces readable error messages with field paths.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement leadProfileSchema with phone normalization and URL validation",
            "description": "Create comprehensive Zod schema for LeadProfile type with all fields, including phone number normalization transform and website URL validation.",
            "dependencies": [
              1
            ],
            "details": "In src/shared/validation/schemas.ts, create leadProfileSchema using z.object() matching LeadProfile interface from src/shared/types/lead.ts. Include: id as z.string().uuid(), business_name as z.string().min(1), address as z.string().nullable(), phone_number with transform that normalizes to E.164 format (strips formatting, adds +1 prefix), website_url using urlSchema.nullable() with transform to ensure https:// prefix, rating using ratingSchema.nullable(), review_count as z.number().int().nonnegative().nullable(), business_category as z.string().nullable(), source_query as z.string(), qualification_score as z.number().int().min(0).max(100), qualification_reasons as z.array(z.string()), status as z.nativeEnum(LeadStatus), discovered_at/updated_at as z.coerce.date(), last_contacted_at/next_followup_at as z.coerce.date().nullable(), notes as z.string().nullable(). Create leadFiltersSchema for LeadFilters type with all optional fields.",
            "status": "pending",
            "testStrategy": "Unit tests with valid LeadProfile data passes validation. Test phone normalization transforms '(555) 123-4567' to '+15551234567'. Test URL normalization adds https:// to 'example.com'. Test rating rejects values outside 1-5 range. Test invalid UUID format is rejected. Test nullable fields accept null values.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement auditResultSchema with score validations and WCAG severity enum",
            "description": "Create Zod schema for AuditResult and related types including PerformanceMetrics, WCAGViolation with severity enum, ResponsiveIssue, and EvidenceUrl.",
            "dependencies": [
              1
            ],
            "details": "In src/shared/validation/schemas.ts, create nested schemas: performanceMetricsSchema with fcp/lcp/tti/tbt as z.number().nonnegative(), cls as z.number().min(0).max(1), speedIndex as z.number().nonnegative(). Create wcagViolationSchema with rule_id as z.string(), severity as z.enum(['critical', 'serious', 'moderate', 'minor']), description/recommendation as z.string(), element_selector as z.string().nullable(), help_url as z.string().url().nullable(). Create responsiveIssueSchema with viewport as z.string(), issue_type as z.enum(['horizontal_overflow', 'touch_target_too_small', 'text_too_small', 'layout_shift']), description as z.string(), element_selector/screenshot_url as z.string().nullable(). Create evidenceUrlSchema with type as z.enum(['screenshot', 'video', 'report']), url as z.string().url(), created_at as z.coerce.date(), expires_at as z.coerce.date().nullable(). Create auditResultSchema with id/lead_id as z.string().uuid(), url as z.string().url(), performance_score/accessibility_score using scoreSchema, arrays of violations/issues/evidence, mobile_friendly as z.boolean(), audited_at as z.coerce.date(), audit_duration_ms as z.number().nonnegative().",
            "status": "pending",
            "testStrategy": "Unit tests verify score fields reject values outside 0-100 range. Test severity enum only accepts valid values. Test nested arrays of violations/issues validate correctly. Test CLS rejects values above 1. Test evidence type enum validation. Test complete AuditResult with all nested objects.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement campaignConfigSchema and searchCriteriaSchema",
            "description": "Create Zod schemas for CampaignConfig with email sequence validation ensuring proper step ordering and delays, plus searchCriteriaSchema for discovery filters.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src/shared/validation/schemas.ts, create emailTemplateSchema matching EmailTemplate interface with id, name, subject, body_html, body_text as required strings, variables as z.array(z.string()). Create emailSequenceStepSchema with step_number as z.number().int().positive(), delay_days as z.number().int().nonnegative(), template_id as z.string(), send_condition as z.enum(['always', 'if_no_response', 'if_opened', 'if_clicked']), max_sends as z.number().int().positive().nullable(). Create campaignConfigSchema with id/template_id as z.string().uuid(), name as z.string().min(1), description as z.string().nullable(), lead_filters using leadFiltersSchema, sequence as z.array(emailSequenceStepSchema).refine() to validate step_number is sequential starting from 1 and delay_days increases, status as z.nativeEnum(CampaignStatus), timestamps as z.coerce.date(). Create searchCriteriaSchema with query as z.string().min(1), location as z.string().min(1), radius as z.number().positive().optional(), category as z.string().optional(), minRating/maxRating using ratingSchema.optional() with refine to ensure min <= max.",
            "status": "pending",
            "testStrategy": "Unit tests verify sequence step_number must be sequential (1,2,3 not 1,3,5). Test delay_days must be non-decreasing. Test send_condition enum validation. Test searchCriteria minRating/maxRating refinement rejects min > max. Test campaignConfig validates nested lead_filters correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create validation utility functions and barrel export",
            "description": "Implement type-safe validation wrapper functions that return properly typed results or throw ValidationError, plus create the index.ts barrel file exporting all schemas and utilities.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "In src/shared/validation/schemas.ts, create typed validation functions: validateLeadProfile(data: unknown): LeadProfile that calls leadProfileSchema.parse() wrapped in try/catch converting ZodError to ValidationError using formatZodError utility. Create validateAuditResult(data: unknown): AuditResult, validateCampaignConfig(data: unknown): CampaignConfig, validateSearchCriteria(data: unknown): SearchCriteria following same pattern. Create safe validation variants that return Result type: safeValidateLeadProfile(data: unknown): { success: true, data: LeadProfile } | { success: false, error: ValidationError }. Create partial validation helpers: validatePartialLeadProfile for update operations using leadProfileSchema.partial(). Create src/shared/validation/index.ts barrel file exporting all schemas (leadProfileSchema, auditResultSchema, etc.), all validation functions (validateLeadProfile, validateAuditResult, etc.), ValidationError class, and utility functions.",
            "status": "pending",
            "testStrategy": "Unit tests verify validateLeadProfile returns typed LeadProfile on valid input. Test it throws ValidationError with detailed field errors on invalid input. Test ValidationError contains all failing field paths and messages. Test safe validation variants return correct discriminated union. Test partial validation allows omitting required fields. Test all exports accessible from index.ts barrel.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create detailed validation rules for edge cases, custom transformers, and comprehensive test coverage for each schema.",
        "updatedAt": "2026-01-30T23:02:01.448Z"
      },
      {
        "id": "6",
        "title": "Setup MCP Client Wrapper for Puppeteer",
        "description": "Create type-safe client wrapper for @modelcontextprotocol/server-puppeteer MCP server with connection management and error handling.",
        "details": "Create src/mcp-servers/puppeteer-client.ts:\n1. PuppeteerClient class:\n   - Constructor accepts config for stealth mode options\n   - connect(): Promise<void> - Initialize MCP connection\n   - disconnect(): Promise<void> - Clean shutdown\n2. Core methods wrapping MCP tools:\n   - navigateTo(url: string, options?: NavigateOptions): Promise<void>\n   - screenshot(options: ScreenshotOptions): Promise<Buffer>\n   - evaluate<T>(fn: () => T): Promise<T>\n   - setViewport(viewport: ViewportConfig): Promise<void>\n   - interceptNetworkResponse(urlPattern: string, handler: ResponseHandler): void\n3. Stealth configuration:\n   - Disable automation flags\n   - Rotate user agents\n   - Handle WebDriver detection\n4. Error handling:\n   - Wrap MCP errors in MCPConnectionError\n   - Implement retry logic with exponential backoff\n   - Timeout handling (default 30s)\n5. Types: NavigateOptions, ScreenshotOptions, ViewportConfig, ResponseHandler",
        "testStrategy": "Integration tests verify MCP server connectivity. Test navigation to known URLs. Test screenshot capture returns valid buffer. Test network interception captures expected responses.",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces and types for Puppeteer client",
            "description": "Create comprehensive TypeScript types for the PuppeteerClient including configuration options, method parameters, and return types.",
            "dependencies": [],
            "details": "Create src/mcp-servers/puppeteer/types.ts with: NavigateOptions (url, waitUntil, timeout, referer), ScreenshotOptions (type, quality, fullPage, clip, encoding), ViewportConfig (width, height, isMobile, deviceScaleFactor, hasTouch), ResponseHandler callback type, PuppeteerClientConfig (stealthMode, userAgents array, defaultTimeout, headless), MCPConnectionError class extending Error with code and originalError properties. Include EvaluateResult<T> generic type for evaluate method returns.",
            "status": "pending",
            "testStrategy": "Type tests using tsd to verify interface contracts compile correctly and enforce required fields.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement PuppeteerClient class with connection management",
            "description": "Create the core PuppeteerClient class with constructor, connect(), and disconnect() methods for MCP server lifecycle management.",
            "dependencies": [
              1
            ],
            "details": "Create src/mcp-servers/puppeteer/client.ts with PuppeteerClient class: constructor accepts PuppeteerClientConfig, stores config and initializes connection state. connect() method establishes MCP transport connection to @modelcontextprotocol/server-puppeteer, validates connection is alive. disconnect() method performs graceful shutdown, closes browser contexts, and cleans up resources. Include private connection state tracking (isConnected boolean, mcpClient instance). Implement connection validation on method calls.",
            "status": "pending",
            "testStrategy": "Integration test verifying connect() establishes connection, disconnect() cleans up, and methods throw when not connected.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement core browser automation methods",
            "description": "Add navigateTo(), screenshot(), evaluate(), setViewport(), and interceptNetworkResponse() methods wrapping MCP tool calls.",
            "dependencies": [
              2
            ],
            "details": "Extend PuppeteerClient with: navigateTo(url, options?) - calls MCP puppeteer_navigate tool with URL and wait options. screenshot(options) - calls MCP puppeteer_screenshot, returns Buffer from base64 response. evaluate<T>(fn) - calls MCP puppeteer_evaluate with serialized function string, parses JSON response. setViewport(config) - sets viewport dimensions via MCP tool. interceptNetworkResponse(urlPattern, handler) - registers response interceptor using page.on('response') equivalent MCP call. Each method validates connection state before calling MCP.",
            "status": "pending",
            "testStrategy": "Integration tests: navigate to test URL verifies page loads, screenshot returns valid PNG buffer, evaluate returns expected values, viewport changes reflected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement stealth mode configuration and anti-detection",
            "description": "Add stealth configuration to disable automation flags, rotate user agents, and handle WebDriver detection bypass.",
            "dependencies": [
              3
            ],
            "details": "Enhance PuppeteerClient with stealth features: private userAgentRotator cycling through config.userAgents array, applyStealthConfig() method called during connect() that sets navigator.webdriver=false, removes automation-related properties, applies random user agent. Add methods: rotateUserAgent() - selects next UA from pool, getRandomDelay(min, max) - for human-like timing. Configure stealth via StealthConfig in constructor: disableAutomationFlags, rotateUserAgentsEnabled, webdriverBypass. Use page.evaluateOnNewDocument for early script injection.",
            "status": "pending",
            "testStrategy": "Test that WebDriver detection scripts return false after stealth applied, user agent rotation cycles correctly through pool.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement error handling with retry logic and timeouts",
            "description": "Add MCPConnectionError wrapper, exponential backoff retry logic, and configurable timeout handling for all operations.",
            "dependencies": [
              4
            ],
            "details": "Create src/mcp-servers/puppeteer/errors.ts with MCPConnectionError class (message, code: CONNECTION_FAILED|TIMEOUT|OPERATION_FAILED, originalError). Add retry utility: withRetry<T>(fn, maxRetries=3, baseDelay=1000) implementing exponential backoff (delay * 2^attempt). Wrap all MCP calls in try-catch converting errors to MCPConnectionError. Add timeout wrapper: withTimeout<T>(fn, timeout=30000) using Promise.race with AbortController. Apply retry and timeout to all public methods. Add config options: defaultTimeout, maxRetries, retryBaseDelay.",
            "status": "pending",
            "testStrategy": "Test retry logic attempts correct number of times with increasing delays, timeout rejects after configured duration, errors wrapped correctly with MCPConnectionError.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail MCP protocol integration, connection lifecycle management, and stealth plugin configuration specifics.",
        "updatedAt": "2026-01-30T23:22:41.419Z"
      },
      {
        "id": "7",
        "title": "Setup MCP Client Wrapper for Supabase",
        "description": "Create type-safe client wrapper for @supabase/mcp-server-postgrest with full CRUD operations and type inference.",
        "details": "Create src/mcp-servers/supabase-client.ts:\n1. SupabaseClient class:\n   - Constructor accepts SUPABASE_URL and SUPABASE_ANON_KEY from config\n   - connect(): Promise<void> - Verify connection\n2. Generic CRUD methods:\n   - select<T>(table: string, query?: QueryOptions): Promise<T[]>\n   - insert<T>(table: string, data: Partial<T>): Promise<T>\n   - update<T>(table: string, id: string, data: Partial<T>): Promise<T>\n   - delete(table: string, id: string): Promise<void>\n3. Query builder helpers:\n   - QueryOptions type with filters, ordering, pagination\n   - Support for complex WHERE clauses\n   - Foreign key joins\n4. Storage operations:\n   - uploadFile(bucket: string, path: string, file: Buffer): Promise<string>\n   - getSignedUrl(bucket: string, path: string, expiresIn: number): Promise<string>\n   - deleteFile(bucket: string, path: string): Promise<void>\n5. Transaction support:\n   - runTransaction<T>(operations: Operation[]): Promise<T>\n6. Error handling: Convert Supabase errors to AppError subtypes",
        "testStrategy": "Integration tests with real Supabase instance. Test CRUD operations on test table. Test file upload/download. Test transaction rollback on failure. Use test data isolation.",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces and types for Supabase client",
            "description": "Create comprehensive TypeScript types for the SupabaseClient including configuration, query options, CRUD operations, storage operations, and error types.",
            "dependencies": [],
            "details": "Create src/mcp-servers/supabase/types.ts with: SupabaseClientConfig (supabaseUrl, supabaseAnonKey, defaultTimeout, maxRetries). QueryOptions interface with filters (FilterOperator enum: eq, neq, gt, gte, lt, lte, like, ilike, in, is), ordering (column, ascending boolean), pagination (limit, offset, cursor). FilterClause type for complex WHERE conditions with and/or combinators. JoinConfig for foreign key relationships (table, foreignKey, columns). StorageOptions (bucket, path, contentType, cacheControl). InsertResult<T>, UpdateResult<T>, DeleteResult generic types. Operation type for transactions with type discriminator (insert|update|delete|select). SupabaseError extending AppError with code (QUERY_FAILED|CONNECTION_FAILED|STORAGE_ERROR|TRANSACTION_FAILED) and originalError.",
            "status": "pending",
            "testStrategy": "Type tests using tsd to verify interface contracts compile correctly, enforce required fields, and generic type inference works with sample table schemas.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement SupabaseClient class with connection management and generic CRUD methods",
            "description": "Create the core SupabaseClient class with constructor, connect(), and type-safe select, insert, update, delete methods wrapping MCP PostgREST calls.",
            "dependencies": [
              1
            ],
            "details": "Create src/mcp-servers/supabase/client.ts with SupabaseClient class: constructor accepts SupabaseClientConfig from config service, stores credentials, initializes connection state. connect() method verifies connection by calling a health check endpoint or simple query. Private method callMCP<T>(tool, params) for making MCP calls. Implement CRUD methods: select<T>(table: string, query?: QueryOptions): Promise<T[]> - builds PostgREST query string from QueryOptions, calls MCP tool, parses response. insert<T>(table: string, data: Partial<T>): Promise<T> - validates data not empty, calls MCP insert, returns created row with generated id. update<T>(table: string, id: string, data: Partial<T>): Promise<T> - calls MCP update with id filter, returns updated row. delete(table: string, id: string): Promise<void> - calls MCP delete with id filter. Each method validates connection state and throws if not connected.",
            "status": "pending",
            "testStrategy": "Integration tests with real Supabase instance: test select returns typed array, insert returns row with id, update modifies correct row, delete removes row. Test connection validation throws when not connected.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement query builder helpers for complex queries and joins",
            "description": "Add advanced query building capabilities supporting complex WHERE clauses with multiple conditions, foreign key joins, and result transformation.",
            "dependencies": [
              2
            ],
            "details": "Enhance SupabaseClient with query builder: private buildWhereClause(filters: FilterClause[]): string - converts FilterClause array to PostgREST query string format, handles and/or combinators, escapes values. private buildOrderClause(ordering: OrderConfig[]): string - generates order query param. private buildSelectClause(columns: string[], joins?: JoinConfig[]): string - handles column selection and foreign key expansion syntax (e.g., 'lead:leads(id,name)'). Add public methods: selectWithJoins<T>(table: string, joins: JoinConfig[], query?: QueryOptions): Promise<T[]> - fetches related data in single query. count(table: string, filters?: FilterClause[]): Promise<number> - returns row count matching filters. exists(table: string, filters: FilterClause[]): Promise<boolean> - efficient existence check. upsert<T>(table: string, data: Partial<T>, conflictColumns: string[]): Promise<T> - insert or update on conflict.",
            "status": "pending",
            "testStrategy": "Integration tests: test complex WHERE with multiple conditions returns correct subset, test join returns nested related data, test count returns accurate number, test upsert creates or updates based on conflict.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement storage operations for file upload and signed URL generation",
            "description": "Add Supabase Storage integration for uploading evidence files, generating signed URLs for time-limited access, and file deletion.",
            "dependencies": [
              2
            ],
            "details": "Extend SupabaseClient with storage methods: uploadFile(bucket: string, path: string, file: Buffer, options?: StorageUploadOptions): Promise<string> - calls MCP storage upload tool, returns public URL or storage path. StorageUploadOptions includes contentType, cacheControl, upsert boolean. getSignedUrl(bucket: string, path: string, expiresIn: number): Promise<string> - generates time-limited signed URL for private bucket access, expiresIn in seconds. deleteFile(bucket: string, path: string): Promise<void> - removes file from storage. listFiles(bucket: string, prefix?: string): Promise<StorageFile[]> - lists files in bucket/folder. StorageFile type with name, id, size, createdAt. Private method validateBucketAccess(bucket: string) - verifies bucket exists and client has permissions. Handle storage-specific errors: FILE_NOT_FOUND, BUCKET_NOT_FOUND, UPLOAD_FAILED with appropriate SupabaseError codes.",
            "status": "pending",
            "testStrategy": "Integration tests: test uploadFile with PNG buffer returns valid URL, test getSignedUrl returns working temporary link, test deleteFile removes file successfully, test listFiles returns correct file metadata. Use test isolation with unique prefixes.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement transaction support and error handling with retry logic",
            "description": "Add transaction execution for atomic multi-operation batches and comprehensive error handling converting Supabase errors to typed AppError subtypes.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add transaction and error handling to SupabaseClient: runTransaction<T>(operations: Operation[]): Promise<T> - executes array of operations atomically using Supabase RPC or batch endpoint, rolls back all on any failure, returns combined result. Operation type includes insert/update/delete/select with table and data properties. Create src/mcp-servers/supabase/errors.ts with error mapping: mapSupabaseError(error: unknown): SupabaseError - converts PostgREST error codes to typed errors (23505 -> UNIQUE_VIOLATION, 23503 -> FOREIGN_KEY_VIOLATION, etc.). Add retry logic: private withRetry<T>(fn: () => Promise<T>, maxRetries?: number): Promise<T> - implements exponential backoff for transient failures (network errors, rate limits). Wrap all public methods with try-catch, map errors appropriately. Add connection retry on disconnect. Export SupabaseError, isSupabaseError type guard, and error code constants from barrel file src/mcp-servers/supabase/index.ts.",
            "status": "pending",
            "testStrategy": "Integration tests: test transaction commits all operations on success, test transaction rolls back all on single failure, test retry logic attempts correct number of times with backoff, test error mapping produces correct SupabaseError subtypes for known PostgreSQL error codes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Specify PostgREST query building patterns, transaction isolation levels, and storage bucket permission handling.",
        "updatedAt": "2026-01-31T04:30:53.759Z"
      },
      {
        "id": "8",
        "title": "Setup MCP Client Wrapper for Mailgun",
        "description": "Create type-safe client wrapper for @mailgun/mailgun-mcp-server with email sending, template rendering, and webhook handling.",
        "details": "Create src/mcp-servers/mailgun-client.ts:\n1. MailgunClient class:\n   - Constructor accepts MAILGUN_API_KEY and MAILGUN_DOMAIN from config\n   - connect(): Promise<void> - Verify API key validity\n2. Email operations:\n   - sendEmail(options: EmailOptions): Promise<SendResult>\n   - sendBulkEmail(recipients: Recipient[], options: BulkEmailOptions): Promise<BulkSendResult>\n   - EmailOptions: to, from, subject, html, text, tracking options\n3. Template operations:\n   - createTemplate(name: string, content: string): Promise<void>\n   - getTemplate(name: string): Promise<Template>\n   - renderTemplate(name: string, variables: Record<string, unknown>): Promise<string>\n4. Tracking:\n   - getMessageEvents(messageId: string): Promise<Event[]>\n   - Event types: delivered, opened, clicked, bounced, complained\n5. Webhook parsing:\n   - parseWebhook(payload: unknown): WebhookEvent\n   - Validate webhook signatures\n6. Rate limiting: Track sends, respect Mailgun limits",
        "testStrategy": "Integration tests with Mailgun sandbox. Test email send returns message ID. Test template rendering with variables. Test webhook parsing with sample payloads.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces and types for Mailgun client",
            "description": "Create comprehensive TypeScript types for the MailgunClient including configuration, email options, template operations, tracking events, and webhook handling types.",
            "dependencies": [],
            "details": "Create src/mcp-servers/mailgun/types.ts with: MailgunClientConfig (apiKey, domain, defaultFrom, defaultTimeout, maxRetries). EmailOptions interface (to: string | string[], from: string, subject: string, html: string, text?: string, cc?: string[], bcc?: string[], replyTo?: string, tags?: string[], tracking?: TrackingOptions). TrackingOptions (opens: boolean, clicks: boolean). SendResult (id: string, message: string, status: 'queued' | 'sent'). Recipient interface (email: string, variables: Record<string, unknown>). BulkEmailOptions extends EmailOptions with recipientVariables support. BulkSendResult (totalAccepted: number, totalRejected: number, messageIds: string[]). Template interface (name: string, description: string, content: string, createdAt: Date, updatedAt: Date). MailgunError extending AppError with code (SEND_FAILED | TEMPLATE_NOT_FOUND | RATE_LIMITED | WEBHOOK_INVALID | API_ERROR) and originalError.",
            "status": "pending",
            "testStrategy": "Type tests using tsd to verify interface contracts compile correctly. Test that EmailOptions enforces required fields (to, subject, html). Test generic Recipient variables typing works with sample data structures.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement MailgunClient class with connection management and email sending methods",
            "description": "Create the core MailgunClient class with constructor, connect(), and email sending methods (sendEmail, sendBulkEmail) wrapping MCP tool calls.",
            "dependencies": [
              1
            ],
            "details": "Create src/mcp-servers/mailgun/client.ts with MailgunClient class: constructor accepts MailgunClientConfig from config service, stores API key and domain, initializes connection state. connect() method verifies API key validity by calling Mailgun domains endpoint via MCP, throws MailgunError on invalid credentials. Private method callMCP<T>(tool: string, params: object): Promise<T> for making MCP calls to @mailgun/mailgun-mcp-server. sendEmail(options: EmailOptions): Promise<SendResult> - validates required fields, builds message payload with proper Mailgun format, calls MCP send tool, returns SendResult with message ID. sendBulkEmail(recipients: Recipient[], options: BulkEmailOptions): Promise<BulkSendResult> - batches recipients (max 1000 per batch per Mailgun limits), uses recipient-variables for personalization, tracks accepted/rejected counts. Private validateEmailOptions(options: EmailOptions): void - throws ValidationError for invalid email formats or missing required fields. Each method validates connection state before calling MCP.",
            "status": "pending",
            "testStrategy": "Integration tests with Mailgun sandbox: test sendEmail returns message ID, test sendBulkEmail batches correctly and returns aggregated results, test connection validation throws on invalid API key, test ValidationError thrown for malformed email addresses.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement template operations for creating, retrieving, and rendering templates",
            "description": "Add template management methods including createTemplate, getTemplate, and renderTemplate with variable substitution support.",
            "dependencies": [
              2
            ],
            "details": "Extend MailgunClient with template methods: createTemplate(name: string, content: string, description?: string): Promise<void> - calls MCP tool to store template in Mailgun, validates name format (alphanumeric, hyphens only), throws if template already exists. getTemplate(name: string): Promise<Template> - retrieves template metadata and content, throws TEMPLATE_NOT_FOUND MailgunError if not found. updateTemplate(name: string, content: string): Promise<void> - updates existing template content. deleteTemplate(name: string): Promise<void> - removes template from Mailgun. listTemplates(): Promise<Template[]> - returns all templates for the domain. renderTemplate(name: string, variables: Record<string, unknown>): Promise<string> - fetches template, performs variable substitution using Handlebars-style syntax ({{variable}}), validates all required variables are provided, returns rendered HTML string. Private extractTemplateVariables(content: string): string[] - parses template to identify required variables for validation.",
            "status": "pending",
            "testStrategy": "Integration tests: test createTemplate stores and retrieves correctly, test renderTemplate substitutes variables accurately, test missing variable throws ValidationError, test TEMPLATE_NOT_FOUND error for non-existent templates, test extractTemplateVariables identifies all {{variable}} patterns.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement tracking operations and webhook parsing with signature validation",
            "description": "Add message event tracking methods and webhook parsing functionality including signature validation for secure webhook handling.",
            "dependencies": [
              2
            ],
            "details": "Extend MailgunClient with tracking and webhook methods: MessageEvent interface (id: string, event: 'delivered' | 'opened' | 'clicked' | 'bounced' | 'complained' | 'unsubscribed' | 'failed', timestamp: Date, recipient: string, messageId: string, details: Record<string, unknown>). getMessageEvents(messageId: string): Promise<MessageEvent[]> - fetches all events for a specific message via MCP, returns chronologically ordered events. getMessageStatus(messageId: string): Promise<'queued' | 'delivered' | 'opened' | 'clicked' | 'bounced' | 'failed'> - returns latest status for message. WebhookEvent type with event-specific discriminated unions for each event type. parseWebhook(payload: unknown, signature: string, timestamp: string): WebhookEvent - validates webhook signature using HMAC-SHA256 with API key, parses payload into typed WebhookEvent, throws WEBHOOK_INVALID MailgunError on signature mismatch or malformed payload. Private verifyWebhookSignature(timestamp: string, token: string, signature: string): boolean - implements Mailgun signature verification algorithm. isValidWebhookTimestamp(timestamp: string): boolean - rejects requests older than 5 minutes to prevent replay attacks.",
            "status": "pending",
            "testStrategy": "Integration tests: test getMessageEvents returns correct event types and order, test webhook signature validation accepts valid signatures and rejects tampered payloads, test parseWebhook returns correctly typed WebhookEvent discriminated union, test timestamp validation rejects old webhooks.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement rate limiting, retry logic, and barrel exports",
            "description": "Add rate limiting to track sends and respect Mailgun limits, implement retry logic with exponential backoff for transient failures, and create barrel export file.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Enhance MailgunClient with rate limiting and error handling: Private RateLimiter class tracking sends per second/minute/hour against Mailgun limits (varies by plan, default 300/min), queueing requests when limit approached. Private withRateLimit<T>(fn: () => Promise<T>): Promise<T> - wraps calls to check/wait for rate limit availability. Add retry logic: private withRetry<T>(fn: () => Promise<T>, maxRetries?: number): Promise<T> - implements exponential backoff (1s, 2s, 4s) for transient failures (network errors, 429 rate limit responses, 5xx errors). getRateLimitStatus(): RateLimitStatus - returns current usage and remaining capacity. resetRateLimitCounters(): void - for testing purposes. Create src/mcp-servers/mailgun/errors.ts with error mapping: mapMailgunError(error: unknown): MailgunError - converts Mailgun API error codes to typed errors. Create barrel file src/mcp-servers/mailgun/index.ts exporting: MailgunClient class, all types from types.ts, MailgunError and error codes, isMailgunError type guard.",
            "status": "pending",
            "testStrategy": "Unit tests: test rate limiter queues requests when limit reached, test retry logic attempts correct number of times with exponential delays, test error mapping produces correct MailgunError subtypes. Integration tests: test rate limiting prevents exceeding Mailgun limits, test all exports accessible from barrel file.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail Mailgun API rate limit handling, webhook signature verification algorithm, and batch recipient validation.",
        "updatedAt": "2026-01-31T13:08:23.728Z"
      },
      {
        "id": "9",
        "title": "Setup MCP Client Wrapper for Google Calendar",
        "description": "Create type-safe client wrapper for @cocal/google-calendar-mcp with availability checking and event management.",
        "details": "Create src/mcp-servers/calendar-client.ts:\n1. CalendarClient class:\n   - Constructor accepts Google OAuth credentials from config\n   - connect(): Promise<void> - Validate refresh token\n2. Availability operations:\n   - getAvailableSlots(calendarId: string, start: Date, end: Date, duration: number): Promise<TimeSlot[]>\n   - checkConflicts(calendarId: string, start: Date, end: Date): Promise<boolean>\n   - TimeSlot type with start, end, available\n3. Event operations:\n   - createEvent(calendarId: string, event: EventInput): Promise<CalendarEvent>\n   - updateEvent(calendarId: string, eventId: string, updates: Partial<EventInput>): Promise<CalendarEvent>\n   - deleteEvent(calendarId: string, eventId: string): Promise<void>\n   - getEvent(calendarId: string, eventId: string): Promise<CalendarEvent>\n4. EventInput type:\n   - summary, description, start, end, attendees, reminders\n5. Timezone handling:\n   - Convert all times to user's timezone\n   - Store in UTC internally\n6. Booking link generation:\n   - generateBookingLink(slots: TimeSlot[], meetingConfig: MeetingConfig): string",
        "testStrategy": "Integration tests with test Google Calendar. Test availability returns slots. Test event creation with attendees. Test timezone conversion accuracy.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CalendarClient Class with OAuth Connection Management",
            "description": "Implement the core CalendarClient class with constructor accepting Google OAuth credentials and connection/disconnection methods.",
            "dependencies": [],
            "details": "Create src/mcp-servers/calendar-client.ts with CalendarClient class. Constructor should accept Google OAuth credentials (clientId, clientSecret, refreshToken) from config. Implement connect(): Promise<void> that validates the refresh token and establishes MCP connection to @cocal/google-calendar-mcp. Implement disconnect(): Promise<void> for clean shutdown. Add private fields for storing connection state, credentials, and MCP client instance. Include error handling for invalid credentials and connection failures.",
            "status": "pending",
            "testStrategy": "Unit test constructor validates required credentials. Integration test connect() successfully authenticates with valid refresh token. Test connect() throws appropriate error with invalid token. Test disconnect() cleanly closes MCP connection.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define TypeScript Types for Calendar Operations",
            "description": "Create comprehensive TypeScript interfaces for TimeSlot, EventInput, CalendarEvent, MeetingConfig, and all supporting types.",
            "dependencies": [
              1
            ],
            "details": "Create types at top of calendar-client.ts or separate types file. Define TimeSlot interface with start: Date, end: Date, available: boolean. Define EventInput interface with summary: string, description?: string, start: Date, end: Date, attendees?: string[], reminders?: ReminderConfig. Define CalendarEvent interface extending EventInput with id, htmlLink, status, creator, created, updated. Define MeetingConfig with duration, title, description, buffer times. Define QueryOptions for list operations with timeMin, timeMax, maxResults.",
            "status": "pending",
            "testStrategy": "Use TypeScript compiler to verify type correctness. Create type tests ensuring required fields are enforced. Test that EventInput can be used to create CalendarEvent with additional fields.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Availability Operations",
            "description": "Implement getAvailableSlots and checkConflicts methods for checking calendar availability within date ranges.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement getAvailableSlots(calendarId: string, start: Date, end: Date, duration: number): Promise<TimeSlot[]> that queries calendar events, identifies free time blocks, and returns available slots matching the required duration. Implement checkConflicts(calendarId: string, start: Date, end: Date): Promise<boolean> that checks if the specified time range overlaps with any existing events. Use MCP tools to fetch events list within the date range. Apply business logic to calculate available slots considering event boundaries and minimum duration requirements.",
            "status": "pending",
            "testStrategy": "Integration test with test calendar containing known events. Test getAvailableSlots returns correct free slots around existing events. Test checkConflicts returns true when time overlaps event. Test checkConflicts returns false for genuinely free time.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Event CRUD Operations",
            "description": "Implement createEvent, updateEvent, deleteEvent, and getEvent methods for full calendar event management.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement createEvent(calendarId: string, event: EventInput): Promise<CalendarEvent> wrapping MCP calendar insert operation. Implement updateEvent(calendarId: string, eventId: string, updates: Partial<EventInput>): Promise<CalendarEvent> wrapping MCP calendar patch operation. Implement deleteEvent(calendarId: string, eventId: string): Promise<void> wrapping MCP calendar delete operation. Implement getEvent(calendarId: string, eventId: string): Promise<CalendarEvent> wrapping MCP calendar get operation. Add proper error handling for not found, permission denied, and validation errors.",
            "status": "pending",
            "testStrategy": "Integration test createEvent returns valid CalendarEvent with generated ID. Test updateEvent modifies specified fields. Test deleteEvent removes event (subsequent get returns 404). Test getEvent retrieves correct event details.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Timezone Handling and Booking Link Generation",
            "description": "Add timezone conversion utilities and implement generateBookingLink method for creating shareable scheduling links.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create private utility methods for timezone conversion: convertToUserTimezone(date: Date, timezone: string): Date and convertToUTC(date: Date, timezone: string): Date. Ensure all internal storage uses UTC and display/input uses user timezone. Implement generateBookingLink(slots: TimeSlot[], meetingConfig: MeetingConfig): string that creates a URL encoding available slots and meeting configuration. Consider using base64 or query parameters for slot encoding. Add timezone field to CalendarClient config. Use libraries like date-fns-tz or luxon for robust timezone handling.",
            "status": "pending",
            "testStrategy": "Test timezone conversion from UTC to various timezones (America/New_York, Europe/London, Asia/Tokyo). Test booking link generation creates valid URL with decodable slot data. Test round-trip: generate link, parse link, verify slots match original.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement OAuth token refresh logic, timezone conversion utilities, and availability slot generation algorithm.",
        "updatedAt": "2026-01-31T14:06:01.309Z"
      },
      {
        "id": "10",
        "title": "Configure Supabase Database Schema",
        "description": "Create and deploy PostgreSQL schema for leads, audits, campaigns, and evidence with proper indexes and foreign keys.",
        "details": "Create supabase/migrations/001_initial_schema.sql:\n1. leads table:\n   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()\n   - business_name TEXT NOT NULL, address TEXT, phone TEXT\n   - website_url TEXT, rating DECIMAL(2,1), review_count INTEGER\n   - category TEXT, search_query TEXT\n   - qualification_score INTEGER, qualification_reasons JSONB DEFAULT '[]'\n   - status TEXT DEFAULT 'pending' CHECK (status IN ('pending','contacted','responded','booked','disqualified'))\n   - created_at, updated_at TIMESTAMPTZ\n2. audits table:\n   - id UUID PRIMARY KEY, lead_id UUID REFERENCES leads(id) ON DELETE CASCADE\n   - url TEXT NOT NULL, performance_score INTEGER, fcp INTEGER, lcp INTEGER, cls DECIMAL\n   - unused_code_percent DECIMAL, accessibility_score INTEGER\n   - wcag_violations JSONB, responsive_issues JSONB, evidence_urls JSONB\n   - audit_date TIMESTAMPTZ, created_at TIMESTAMPTZ\n3. campaigns table:\n   - id UUID PRIMARY KEY, name TEXT NOT NULL, template_id TEXT\n   - lead_filters JSONB, sequence JSONB, status TEXT\n4. email_events table for tracking\n5. Indexes: idx_leads_status, idx_leads_website, idx_audits_lead_id, idx_campaigns_status\n6. Create storage bucket 'evidence' for screenshots/videos",
        "testStrategy": "Run migrations on fresh Supabase instance. Verify all tables created with correct columns. Test foreign key constraints. Insert seed data successfully.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create leads table with all required columns and constraints",
            "description": "Create the leads table in the Supabase migration file with UUID primary key, business info columns, qualification fields, status enum constraint, and timestamps.",
            "dependencies": [],
            "details": "Create supabase/migrations/001_initial_schema.sql and define the leads table with: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), business_name TEXT NOT NULL, address TEXT, phone TEXT, website_url TEXT, rating DECIMAL(2,1), review_count INTEGER, category TEXT, search_query TEXT, qualification_score INTEGER, qualification_reasons JSONB DEFAULT '[]', status TEXT DEFAULT 'pending' CHECK (status IN ('pending','contacted','responded','booked','disqualified')), created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW(). Include a trigger function to auto-update updated_at on row changes.",
            "status": "pending",
            "testStrategy": "Run migration on fresh Supabase instance. Verify table exists with \\d leads. Insert test row with minimal required fields (business_name). Test status constraint rejects invalid values. Test default values are applied correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create audits table with foreign key relationship to leads",
            "description": "Create the audits table to store website audit results with foreign key reference to leads table and ON DELETE CASCADE behavior.",
            "dependencies": [
              1
            ],
            "details": "Add audits table to the migration file with: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), lead_id UUID NOT NULL REFERENCES leads(id) ON DELETE CASCADE, url TEXT NOT NULL, performance_score INTEGER, fcp INTEGER (First Contentful Paint in ms), lcp INTEGER (Largest Contentful Paint in ms), cls DECIMAL(5,4) (Cumulative Layout Shift), unused_code_percent DECIMAL(5,2), accessibility_score INTEGER, wcag_violations JSONB DEFAULT '[]', responsive_issues JSONB DEFAULT '[]', evidence_urls JSONB DEFAULT '[]', audit_date TIMESTAMPTZ DEFAULT NOW(), created_at TIMESTAMPTZ DEFAULT NOW().",
            "status": "pending",
            "testStrategy": "Insert a lead, then insert an audit referencing that lead_id. Verify foreign key constraint prevents orphan audits. Test CASCADE deletion removes audits when lead is deleted. Verify JSONB columns accept valid JSON arrays.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create campaigns and email_events tables for outreach tracking",
            "description": "Create the campaigns table for email sequence configuration and email_events table for tracking delivery, opens, clicks, and responses.",
            "dependencies": [
              1
            ],
            "details": "Add campaigns table with: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name TEXT NOT NULL, template_id TEXT, lead_filters JSONB DEFAULT '{}', sequence JSONB DEFAULT '[]' (array of email steps with delays), status TEXT DEFAULT 'draft' CHECK (status IN ('draft','active','paused','completed')), created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW(). Add email_events table with: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), lead_id UUID REFERENCES leads(id) ON DELETE CASCADE, campaign_id UUID REFERENCES campaigns(id) ON DELETE SET NULL, event_type TEXT NOT NULL CHECK (event_type IN ('sent','delivered','opened','clicked','replied','bounced','unsubscribed')), metadata JSONB DEFAULT '{}', occurred_at TIMESTAMPTZ DEFAULT NOW().",
            "status": "pending",
            "testStrategy": "Create a campaign, send test events linked to leads. Verify event_type constraint. Test that deleting a lead cascades to email_events but deleting a campaign only nullifies campaign_id. Verify sequence JSONB stores email step configurations correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create database indexes for query performance optimization",
            "description": "Add indexes on frequently queried columns including leads status, website_url, audits lead_id, and campaigns status for optimal query performance.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add the following indexes to the migration file: CREATE INDEX idx_leads_status ON leads(status) for filtering leads by outreach stage; CREATE INDEX idx_leads_website ON leads(website_url) for deduplication checks; CREATE INDEX idx_leads_created ON leads(created_at DESC) for sorting by discovery date; CREATE INDEX idx_audits_lead_id ON audits(lead_id) for joining audits to leads; CREATE INDEX idx_audits_performance ON audits(performance_score) for filtering by score; CREATE INDEX idx_campaigns_status ON campaigns(status) for active campaign queries; CREATE INDEX idx_email_events_lead ON email_events(lead_id, occurred_at DESC) for lead activity timeline.",
            "status": "pending",
            "testStrategy": "Run EXPLAIN ANALYZE on common queries (SELECT * FROM leads WHERE status = 'pending', SELECT * FROM audits WHERE lead_id = ...) and verify indexes are being used. Compare query times before and after index creation on sample data set of 1000+ rows.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Supabase storage bucket for evidence files",
            "description": "Configure Supabase storage bucket named 'evidence' for storing audit screenshots, slow-load videos, and PDF reports with appropriate access policies.",
            "dependencies": [],
            "details": "Add storage bucket creation to the migration or create a separate supabase/storage.sql file. Create 'evidence' bucket with: INSERT INTO storage.buckets (id, name, public) VALUES ('evidence', 'evidence', true); Add RLS policies for authenticated uploads: CREATE POLICY \"Allow authenticated uploads\" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'evidence'); CREATE POLICY \"Allow public read\" ON storage.objects FOR SELECT TO public USING (bucket_id = 'evidence'). Define folder structure convention: evidence/{lead_id}/screenshots/, evidence/{lead_id}/videos/, evidence/{lead_id}/reports/.",
            "status": "pending",
            "testStrategy": "Verify bucket exists via Supabase dashboard or CLI. Test file upload with supabase.storage.from('evidence').upload(). Verify public URLs are accessible without authentication. Test that unauthenticated uploads are rejected. Verify folder structure works with path-based uploads.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Include RLS policy definitions, trigger functions for audit trails, and comprehensive index analysis.",
        "updatedAt": "2026-01-30T23:16:33.268Z"
      },
      {
        "id": "11",
        "title": "Implement Lead Repository for Data Persistence",
        "description": "Build the lead repository module with full CRUD operations, search functionality, and data validation.",
        "details": "Create src/data-layer/lead-repository.ts:\n1. LeadRepository class:\n   - Constructor receives SupabaseClient instance\n2. CRUD operations:\n   - saveLead(lead: Omit<LeadProfile, 'id'>): Promise<LeadProfile>\n     * Validate with Zod before insert\n     * Check for duplicates by website_url (upsert logic)\n   - getLeadById(id: string): Promise<LeadProfile | null>\n   - updateLead(id: string, updates: Partial<LeadProfile>): Promise<LeadProfile>\n   - deleteLead(id: string): Promise<void>\n3. Search operations:\n   - searchLeads(filters: LeadFilters): Promise<PaginatedResult<LeadProfile>>\n     * Support status, category, rating range, date range filters\n     * Pagination with cursor or offset\n     * Sorting by multiple fields\n   - getLeadsByStatus(status: LeadStatus): Promise<LeadProfile[]>\n   - getLeadsForCampaign(campaignId: string): Promise<LeadProfile[]>\n4. Bulk operations:\n   - saveLeadsBatch(leads: LeadProfile[]): Promise<LeadProfile[]>\n   - updateLeadsBatch(updates: Array<{id: string, data: Partial<LeadProfile>}>): Promise<void>\n5. Deduplication:\n   - findDuplicateByWebsite(url: string): Promise<LeadProfile | null>",
        "testStrategy": "Integration tests with real Supabase. Test save/get/update/delete cycle. Test search with various filters. Test duplicate detection. Test bulk operations. Use transaction rollback for cleanup.",
        "priority": "high",
        "dependencies": [
          "5",
          "7",
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LeadRepository class with constructor and SupabaseClient integration",
            "description": "Implement the foundational LeadRepository class that accepts a SupabaseClient instance and establishes the connection pattern for all data operations.",
            "dependencies": [],
            "details": "Create src/data-layer/lead-repository.ts with LeadRepository class. Constructor accepts SupabaseClient instance from src/mcp-servers/supabase/client.ts and stores it as private readonly property. Define private table name constant 'lead_profiles'. Import LeadProfile, LeadStatus, and LeadFilters types from src/shared/types/lead.ts. Import validation schemas from src/shared/validation/schemas.ts. Create private helper method validateConnection() that throws if client not connected. Add private method mapDbRowToLeadProfile(row: unknown): LeadProfile for transforming database responses to typed domain objects with proper date parsing for discovered_at, updated_at, last_contacted_at, next_followup_at fields.",
            "status": "pending",
            "testStrategy": "Unit tests verify constructor stores client instance, validateConnection throws when disconnected, mapDbRowToLeadProfile correctly transforms database row with all field types including null handling and date parsing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CRUD operations with Zod validation and upsert logic",
            "description": "Add saveLead, getLeadById, updateLead, and deleteLead methods with full Zod validation before database operations and duplicate detection by website_url.",
            "dependencies": [
              1
            ],
            "details": "Implement CRUD methods in LeadRepository: saveLead(lead: Omit<LeadProfile, 'id'>): Promise<LeadProfile> - validate input with leadProfileSchema.omit({id: true}) before insert, call findDuplicateByWebsite() first, if duplicate exists perform upsert with update, otherwise insert new row, return created/updated LeadProfile. getLeadById(id: string): Promise<LeadProfile | null> - validate UUID format, call supabaseClient.select with id filter, return null if not found, map result with mapDbRowToLeadProfile. updateLead(id: string, updates: Partial<LeadProfile>): Promise<LeadProfile> - validate id exists first with getLeadById, validate updates with leadProfileSchema.partial(), set updated_at to current timestamp, call supabaseClient.update, return updated LeadProfile. deleteLead(id: string): Promise<void> - validate id exists, call supabaseClient.delete, handle not found gracefully. Each method wraps errors in appropriate AppError subtype (ValidationError, NotFoundError).",
            "status": "pending",
            "testStrategy": "Integration tests with real Supabase verify: saveLead creates new record with generated UUID, saveLead with existing website_url performs upsert, getLeadById returns null for non-existent id, updateLead modifies only specified fields, deleteLead removes record. Test Zod validation rejects invalid data with detailed field errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement search operations with filtering, pagination, and sorting",
            "description": "Add searchLeads method supporting status, category, rating range, date range filters with cursor/offset pagination and multi-field sorting, plus getLeadsByStatus and getLeadsForCampaign convenience methods.",
            "dependencies": [
              1
            ],
            "details": "Implement search methods in LeadRepository: searchLeads(filters: LeadFilters): Promise<PaginatedResult<LeadProfile>> - import PaginatedResult from src/shared/types/common.ts, build dynamic query from LeadFilters (status array using 'in' operator, category using 'eq', minRating/maxRating using 'gte'/'lte', discoveredAfter/discoveredBefore for date range, hasWebsite checks website_url is not null), support pagination with page/pageSize or cursor-based using id, support sorting by multiple fields (sortBy: string[], sortOrder: ('asc'|'desc')[]), execute count query for total, return {items, total, page, pageSize, hasMore}. getLeadsByStatus(status: LeadStatus): Promise<LeadProfile[]> - simple filter by single status, no pagination for convenience use cases. getLeadsForCampaign(campaignId: string): Promise<LeadProfile[]> - join with campaign_leads junction table or filter by campaign-specific criteria based on schema design, return all matching leads.",
            "status": "pending",
            "testStrategy": "Integration tests verify: searchLeads with status filter returns only matching statuses, rating range filter works correctly at boundaries, pagination returns correct page with hasMore flag, sorting by multiple fields orders correctly. Test getLeadsByStatus returns all leads with given status. Test empty results return empty array not null.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement bulk operations for batch save and update",
            "description": "Add saveLeadsBatch and updateLeadsBatch methods for efficient multi-record operations with transaction support and partial failure handling.",
            "dependencies": [
              2
            ],
            "details": "Implement bulk methods in LeadRepository: saveLeadsBatch(leads: Omit<LeadProfile, 'id'>[]): Promise<LeadProfile[]> - validate each lead with leadProfileSchema, check for duplicates within batch (by website_url) and against existing records, use supabaseClient.runTransaction for atomic insert of all valid leads, return array of created LeadProfiles with generated IDs in same order as input. updateLeadsBatch(updates: Array<{id: string, data: Partial<LeadProfile>}>): Promise<void> - validate each update object, batch updates into single transaction using supabaseClient.runTransaction, all updates succeed or all fail atomically, set updated_at timestamp on each record. Handle partial validation failures by collecting all validation errors and throwing single ValidationError with all field issues. Consider chunking for very large batches (>100 records) to avoid timeout.",
            "status": "pending",
            "testStrategy": "Integration tests verify: saveLeadsBatch creates all records atomically, saveLeadsBatch rolls back all on single validation failure, saveLeadsBatch handles duplicate detection within batch, updateLeadsBatch modifies all specified records, updateLeadsBatch rolls back on single invalid id. Test with varying batch sizes including edge cases (empty array, single item, large batch).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement deduplication with findDuplicateByWebsite and module exports",
            "description": "Add findDuplicateByWebsite method for duplicate detection by website URL with normalization, create barrel export file, and export LeadRepository with all types.",
            "dependencies": [
              1
            ],
            "details": "Implement deduplication in LeadRepository: findDuplicateByWebsite(url: string): Promise<LeadProfile | null> - normalize URL before search (lowercase, remove trailing slash, strip www prefix, extract domain+path without query params and fragments), query lead_profiles table with normalized website_url using 'eq' filter, return first match or null if none found. Add private normalizeUrl(url: string): string helper method for consistent URL normalization across save and search operations. Create src/data-layer/index.ts barrel file exporting: LeadRepository class, re-export relevant types from src/shared/types (LeadProfile, LeadStatus, LeadFilters, PaginatedResult). Create src/data-layer/repositories/index.ts if using subdirectory structure. Add JSDoc comments to all public methods documenting parameters, return values, and thrown errors.",
            "status": "pending",
            "testStrategy": "Integration tests verify: findDuplicateByWebsite returns existing lead with matching normalized URL, findDuplicateByWebsite returns null for non-existent URL, URL normalization handles variations (http vs https, www vs non-www, trailing slashes, query params). Test barrel exports are accessible. Test JSDoc generates correct type hints in IDE.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail query optimization strategies, transaction boundaries, and deduplication normalization logic.",
        "updatedAt": "2026-01-31T05:11:29.922Z"
      },
      {
        "id": "12",
        "title": "Build Lead Status Tracking System",
        "description": "Implement status transition management with validation, history tracking, and webhook triggers.",
        "details": "Create src/data-layer/status-tracker.ts:\n1. StatusTracker class:\n   - Constructor receives LeadRepository instance\n2. Status transition logic:\n   - VALID_TRANSITIONS map:\n     * pending -> contacted, disqualified\n     * contacted -> responded, disqualified\n     * responded -> booked, disqualified\n     * booked -> (terminal state)\n     * disqualified -> (terminal state)\n   - updateLeadStatus(id: string, newStatus: LeadStatus, notes?: string): Promise<LeadProfile>\n     * Validate transition is allowed\n     * Throw ValidationError if invalid transition\n     * Timestamp the change\n3. Status history:\n   - Create status_history table in migration\n   - logStatusChange(leadId: string, fromStatus: LeadStatus, toStatus: LeadStatus, reason?: string)\n   - getStatusHistory(leadId: string): Promise<StatusHistoryEntry[]>\n4. Webhook integration:\n   - onStatusChange callback registration\n   - Trigger webhooks on specific transitions (e.g., booked -> notify sales)\n5. Bulk status updates:\n   - updateStatusBatch(leadIds: string[], status: LeadStatus): Promise<void>",
        "testStrategy": "Unit tests for state machine logic (valid/invalid transitions). Integration tests for persistence. Test history logging. Test webhook triggers fire correctly.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Status Transition Map and Validation Logic",
            "description": "Define the VALID_TRANSITIONS map and implement the core status transition validation function that enforces the allowed state changes.",
            "dependencies": [],
            "details": "Create src/data-layer/status-tracker.ts with: 1) LeadStatus enum (pending, contacted, responded, booked, disqualified), 2) VALID_TRANSITIONS constant Map<LeadStatus, LeadStatus[]> defining allowed transitions (pending->contacted/disqualified, contacted->responded/disqualified, responded->booked/disqualified, booked/disqualified as terminal states), 3) isValidTransition(fromStatus, toStatus) helper function, 4) ValidationError import from shared errors for invalid transitions.",
            "status": "pending",
            "testStrategy": "Unit tests for all valid transitions pass, invalid transitions throw ValidationError, terminal states reject all transitions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement StatusTracker Class with Core Update Method",
            "description": "Build the StatusTracker class with constructor accepting LeadRepository and implement the updateLeadStatus method with validation and timestamping.",
            "dependencies": [
              1
            ],
            "details": "Extend status-tracker.ts with StatusTracker class: 1) Constructor receives LeadRepository instance and stores reference, 2) updateLeadStatus(id: string, newStatus: LeadStatus, notes?: string): Promise<LeadProfile> that fetches current lead, validates transition using isValidTransition(), throws ValidationError with descriptive message if invalid, timestamps the change with updated_at, persists via repository, and returns updated LeadProfile.",
            "status": "pending",
            "testStrategy": "Unit tests verify valid status updates succeed and return updated profile, invalid transitions throw ValidationError with correct code, timestamps are set correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Status History Table and Logging Functions",
            "description": "Create database migration for status_history table and implement history logging and retrieval methods in StatusTracker.",
            "dependencies": [
              2
            ],
            "details": "1) Create supabase/migrations/xxx_status_history.sql with status_history table (id UUID, lead_id UUID FK, from_status TEXT, to_status TEXT, reason TEXT nullable, changed_at TIMESTAMPTZ, index on lead_id), 2) Add logStatusChange(leadId, fromStatus, toStatus, reason?) private method that inserts history record, 3) Add getStatusHistory(leadId): Promise<StatusHistoryEntry[]> method returning ordered history, 4) Call logStatusChange from updateLeadStatus before returning.",
            "status": "pending",
            "testStrategy": "Integration tests verify history records are created on status changes, getStatusHistory returns correct ordered entries, reason field is optional.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Webhook Integration for Status Changes",
            "description": "Add webhook callback registration and triggering system for specific status transitions like booked notifications.",
            "dependencies": [
              2
            ],
            "details": "Extend StatusTracker with: 1) private webhookCallbacks: Map<LeadStatus, Array<(lead: LeadProfile) => Promise<void>>> for storing registered callbacks, 2) onStatusChange(targetStatus: LeadStatus, callback: (lead: LeadProfile) => Promise<void>) registration method, 3) private triggerWebhooks(lead: LeadProfile, newStatus: LeadStatus) that iterates registered callbacks for the status and executes them, 4) Call triggerWebhooks in updateLeadStatus after successful update, 5) Handle webhook errors gracefully without failing the status update.",
            "status": "pending",
            "testStrategy": "Unit tests verify callbacks are registered correctly, triggered on matching status transitions, multiple callbacks fire, webhook errors don't fail status updates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Bulk Status Update Method",
            "description": "Add updateStatusBatch method for efficiently updating multiple leads to the same status with validation and history logging.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Add to StatusTracker: 1) updateStatusBatch(leadIds: string[], status: LeadStatus, reason?: string): Promise<void> that fetches all leads by IDs, validates each transition individually collecting errors, performs batch update via repository for valid leads, logs history for each change, triggers webhooks for each updated lead, 2) Return summary or throw aggregate error if any validations failed, 3) Consider transaction wrapper for atomicity.",
            "status": "pending",
            "testStrategy": "Integration tests verify batch updates succeed for valid transitions, partial failures are handled correctly, history logged for each lead, webhooks triggered per lead.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define complete state machine transitions, webhook callback registration patterns, and history query optimization.",
        "updatedAt": "2026-01-31T05:13:09.824Z"
      },
      {
        "id": "13",
        "title": "Create Evidence Storage Module",
        "description": "Implement file upload, signed URL generation, and cleanup for visual evidence assets.",
        "details": "Create src/data-layer/evidence-store.ts:\n1. EvidenceStore class:\n   - Constructor receives SupabaseClient instance\n   - BUCKET_NAME = 'evidence'\n2. Upload operations:\n   - storeEvidence(leadId: string, file: Buffer, type: EvidenceType, filename: string): Promise<EvidenceUrl>\n     * EvidenceType: 'screenshot' | 'video' | 'report'\n     * Generate unique path: {leadId}/{type}/{timestamp}_{filename}\n     * Upload to Supabase Storage\n     * Return signed URL with 7-day expiration\n   - storeMultipleEvidence(leadId: string, files: EvidenceFile[]): Promise<EvidenceUrl[]>\n3. Retrieval:\n   - getEvidenceForLead(leadId: string): Promise<EvidenceUrl[]>\n   - refreshSignedUrl(path: string): Promise<string>\n4. Cleanup:\n   - deleteEvidenceForLead(leadId: string): Promise<void>\n   - cleanupOrphanedFiles(): Promise<number> (cron job helper)\n5. Size limits:\n   - MAX_FILE_SIZE = 50MB\n   - Validate before upload, throw ValidationError if exceeded\n6. Supported formats:\n   - Screenshots: PNG, JPEG, WebP\n   - Videos: WebM, MP4\n   - Reports: PDF",
        "testStrategy": "Integration tests upload/download files. Test signed URLs work within expiration. Test size limit rejection. Test cleanup removes correct files.",
        "priority": "medium",
        "dependencies": [
          "7",
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Evidence Types and Interfaces",
            "description": "Create TypeScript types and interfaces for evidence storage operations including EvidenceType, EvidenceUrl, EvidenceFile, and ValidationError.",
            "dependencies": [],
            "details": "Create src/data-layer/evidence-store.ts with type definitions: EvidenceType union type ('screenshot' | 'video' | 'report'), EvidenceUrl interface with path, url, type, and expiresAt fields, EvidenceFile interface for batch uploads with buffer, type, and filename. Define ValidationError class extending Error for size/format validation failures. Add constants: BUCKET_NAME = 'evidence', MAX_FILE_SIZE = 50 * 1024 * 1024 (50MB), SUPPORTED_FORMATS map with screenshot extensions ['.png', '.jpeg', '.jpg', '.webp'], video extensions ['.webm', '.mp4'], and report extensions ['.pdf'].",
            "status": "pending",
            "testStrategy": "Unit tests verify type exports are correct. Test ValidationError can be thrown and caught with appropriate message.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement EvidenceStore Class with Upload Operations",
            "description": "Create the EvidenceStore class with constructor accepting SupabaseClient and implement storeEvidence and storeMultipleEvidence methods.",
            "dependencies": [
              1
            ],
            "details": "Implement EvidenceStore class constructor that receives SupabaseClient instance and stores it. Create storeEvidence(leadId: string, file: Buffer, type: EvidenceType, filename: string): Promise<EvidenceUrl> method that: 1) Validates file size against MAX_FILE_SIZE throwing ValidationError if exceeded, 2) Validates file extension matches SUPPORTED_FORMATS for the given type, 3) Generates unique path using template {leadId}/{type}/{timestamp}_{filename} where timestamp is Date.now(), 4) Uploads to Supabase Storage bucket using client.storage.from(BUCKET_NAME).upload(), 5) Generates signed URL with 7-day expiration using createSignedUrl(), 6) Returns EvidenceUrl object. Implement storeMultipleEvidence using Promise.all() to upload array of EvidenceFile objects in parallel.",
            "status": "pending",
            "testStrategy": "Integration tests upload actual files to Supabase Storage. Test file size validation rejects files over 50MB. Test invalid format rejection. Test unique path generation includes timestamp.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Evidence Retrieval Methods",
            "description": "Add getEvidenceForLead and refreshSignedUrl methods to retrieve stored evidence and refresh expiring URLs.",
            "dependencies": [
              2
            ],
            "details": "Implement getEvidenceForLead(leadId: string): Promise<EvidenceUrl[]> that: 1) Lists all files in the bucket under the {leadId}/ prefix using client.storage.from(BUCKET_NAME).list(leadId), 2) Recursively lists subdirectories (screenshot/, video/, report/), 3) Generates fresh signed URLs for each file with 7-day expiration, 4) Returns array of EvidenceUrl objects with type inferred from path. Implement refreshSignedUrl(path: string): Promise<string> that creates a new signed URL for an existing file path, useful when URLs are approaching expiration. Handle cases where files don't exist by throwing appropriate errors.",
            "status": "pending",
            "testStrategy": "Integration tests verify list returns all uploaded files for a lead. Test signed URLs are valid and accessible. Test refresh generates new URL with extended expiration.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Cleanup Operations",
            "description": "Add deleteEvidenceForLead for removing all evidence when a lead is deleted and cleanupOrphanedFiles for maintenance cron jobs.",
            "dependencies": [
              3
            ],
            "details": "Implement deleteEvidenceForLead(leadId: string): Promise<void> that: 1) Lists all files under {leadId}/ prefix recursively, 2) Deletes all files using client.storage.from(BUCKET_NAME).remove(filePaths), 3) Handles empty directories gracefully. Implement cleanupOrphanedFiles(): Promise<number> as a cron job helper that: 1) Lists all top-level directories (lead IDs) in the bucket, 2) Queries LeadRepository to check which lead IDs still exist, 3) Deletes evidence directories for leads that no longer exist in the database, 4) Returns count of deleted files for logging. Add optional constructor parameter for LeadRepository dependency needed by cleanup.",
            "status": "pending",
            "testStrategy": "Integration tests verify delete removes all files for a lead. Test cleanup identifies and removes orphaned directories. Test cleanup returns accurate count of deleted files.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Validation Helpers and Export Module",
            "description": "Create private validation helper methods and export all public types and the EvidenceStore class from the module.",
            "dependencies": [
              4
            ],
            "details": "Create private helper methods: validateFileSize(buffer: Buffer): void throws ValidationError if buffer.length > MAX_FILE_SIZE with message including actual size and limit, validateFileFormat(filename: string, type: EvidenceType): void throws ValidationError if file extension not in SUPPORTED_FORMATS[type], getFileExtension(filename: string): string extracts lowercase extension from filename, generateUniquePath(leadId: string, type: EvidenceType, filename: string): string creates the storage path. Refactor storeEvidence to use these helpers. Export EvidenceStore class, all interfaces (EvidenceType, EvidenceUrl, EvidenceFile), ValidationError class, and constants (MAX_FILE_SIZE, SUPPORTED_FORMATS) from the module. Add JSDoc comments to public methods documenting parameters, return types, and thrown errors.",
            "status": "pending",
            "testStrategy": "Unit tests verify validation helpers reject invalid inputs with correct error messages. Test module exports are all accessible. Test JSDoc generates correct documentation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Specify file format validation regexes, signed URL expiration strategies, and orphaned file cleanup cron logic.",
        "updatedAt": "2026-01-31T14:09:01.885Z"
      },
      {
        "id": "14",
        "title": "Implement Analytics Data Aggregation",
        "description": "Build analytics module for conversion rates, funnel metrics, and time-series reporting.",
        "details": "Create src/data-layer/analytics.ts:\n1. AnalyticsService class:\n   - Constructor receives SupabaseClient instance\n2. Funnel metrics:\n   - getConversionFunnel(dateRange: DateRange): Promise<FunnelMetrics>\n     * Returns counts at each status stage\n     * Calculates conversion rates between stages\n   - FunnelMetrics: { pending, contacted, responded, booked, disqualified, conversionRates }\n3. Performance metrics:\n   - getCampaignPerformance(campaignId: string): Promise<CampaignMetrics>\n     * sent, delivered, opened, clicked, replied counts\n     * Open rate, click rate, reply rate percentages\n   - getOverallMetrics(dateRange: DateRange): Promise<OverallMetrics>\n4. Time-series:\n   - getLeadsTrend(dateRange: DateRange, interval: 'day' | 'week' | 'month'): Promise<TimeSeriesData[]>\n   - getResponseTrend(campaignId: string, interval: 'day'): Promise<TimeSeriesData[]>\n5. Aggregations:\n   - getTopPerformingCategories(limit: number): Promise<CategoryMetrics[]>\n   - getQualificationDistribution(): Promise<ScoreDistribution>\n6. Caching:\n   - Cache frequently accessed aggregations\n   - Invalidate on data changes\n7. SQL queries use PostgreSQL aggregate functions (COUNT, AVG, SUM, GROUP BY)",
        "testStrategy": "Integration tests with known dataset verify calculation accuracy. Test time-series grouping. Test cache invalidation. Test empty data handling.",
        "priority": "medium",
        "dependencies": [
          "11",
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AnalyticsService Class Foundation with DateRange Types",
            "description": "Set up the base AnalyticsService class structure with SupabaseClient dependency injection, define DateRange, FunnelMetrics, CampaignMetrics, and TimeSeriesData type interfaces.",
            "dependencies": [],
            "details": "Create src/data-layer/analytics.ts with: 1) AnalyticsService class with constructor receiving SupabaseClient instance, 2) Define TypeScript interfaces: DateRange (startDate, endDate as Date), FunnelMetrics (pending, contacted, responded, booked, disqualified counts + conversionRates object), CampaignMetrics (sent, delivered, opened, clicked, replied counts + openRate, clickRate, replyRate percentages), TimeSeriesData (date, value, optionally label), CategoryMetrics (category, leadCount, conversionRate), ScoreDistribution (score ranges with counts). Export all types for use in other modules.",
            "status": "pending",
            "testStrategy": "Unit tests verify class instantiation with mocked SupabaseClient. Test type exports are accessible. Test constructor stores client reference correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Funnel Metrics and Conversion Rate Calculations",
            "description": "Build getConversionFunnel method that queries lead status distribution and calculates conversion rates between pipeline stages.",
            "dependencies": [
              1
            ],
            "details": "Implement getConversionFunnel(dateRange: DateRange): Promise<FunnelMetrics> that: 1) Executes PostgreSQL query with COUNT and GROUP BY on lead status within date range, 2) Returns counts for each status stage (pending, contacted, responded, booked, disqualified), 3) Calculates conversion rates between stages (contacted/pending, responded/contacted, booked/responded), 4) Handle empty results gracefully returning zero counts. SQL should use: SELECT status, COUNT(*) as count FROM lead_profiles WHERE discovered_at BETWEEN $1 AND $2 GROUP BY status. Include getStatusFunnelOrder() helper to define stage sequence.",
            "status": "pending",
            "testStrategy": "Integration tests with known dataset (10 pending, 8 contacted, 5 responded, 2 booked) verify calculation accuracy. Test conversion rate math (80%, 62.5%, 40%). Test empty date range returns zeros.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Campaign and Overall Performance Metrics",
            "description": "Build getCampaignPerformance and getOverallMetrics methods for tracking email engagement rates and system-wide statistics.",
            "dependencies": [
              1
            ],
            "details": "Implement: 1) getCampaignPerformance(campaignId: string): Promise<CampaignMetrics> - Query email_events table aggregating sent, delivered, opened, clicked, replied counts for specific campaign, calculate percentages (openRate=opened/delivered*100, clickRate=clicked/opened*100, replyRate=replied/sent*100). 2) getOverallMetrics(dateRange: DateRange): Promise<OverallMetrics> - Aggregate across all campaigns within date range, include totalLeads, activeLeads, emailsSent, avgResponseRate. Use PostgreSQL aggregate functions with JOINs between campaigns and email_events tables. Handle division by zero for rate calculations.",
            "status": "pending",
            "testStrategy": "Integration tests verify campaign metrics match expected values. Test rate calculations handle zero denominators. Test overall metrics aggregate correctly across multiple campaigns.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Time-Series Trend Queries with Interval Grouping",
            "description": "Build getLeadsTrend and getResponseTrend methods for generating time-bucketed data suitable for charts and trend analysis.",
            "dependencies": [
              1
            ],
            "details": "Implement: 1) getLeadsTrend(dateRange: DateRange, interval: 'day' | 'week' | 'month'): Promise<TimeSeriesData[]> - Use PostgreSQL date_trunc() to bucket discovered_at by interval, COUNT leads per bucket, return ordered array. 2) getResponseTrend(campaignId: string, interval: 'day'): Promise<TimeSeriesData[]> - Bucket email responses by date for campaign. SQL pattern: SELECT date_trunc($1, discovered_at) as bucket, COUNT(*) FROM lead_profiles WHERE discovered_at BETWEEN $2 AND $3 GROUP BY bucket ORDER BY bucket. Fill gaps in date ranges with zero counts for consistent chart rendering.",
            "status": "pending",
            "testStrategy": "Test day/week/month grouping produces correct buckets. Test gap filling creates entries for dates with no data. Test response trend filters by campaignId correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Aggregation Queries and Caching Layer",
            "description": "Build category performance rankings, score distribution queries, and implement caching with invalidation for frequently accessed metrics.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement: 1) getTopPerformingCategories(limit: number): Promise<CategoryMetrics[]> - GROUP BY business_category, calculate lead count and conversion rate per category, ORDER BY conversion rate DESC LIMIT $1. 2) getQualificationDistribution(): Promise<ScoreDistribution> - Bucket performance_score into ranges (0-25, 26-50, 51-75, 76-100), COUNT leads per bucket. 3) Caching layer: Create private cache Map with TTL (5 minutes default), cache keys based on method name + params hash, getCachedOrFetch() helper that checks cache before executing query. 4) Invalidation: exposeInvalidateCache() method called when lead data changes, subscribe to Supabase realtime changes on lead_profiles table to auto-invalidate.",
            "status": "pending",
            "testStrategy": "Test category ranking orders correctly by conversion. Test score distribution buckets leads accurately. Test cache returns stored value on second call. Test invalidation clears cache. Test empty data handling for all aggregations.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Optimize SQL queries for funnel metrics, implement cache invalidation strategies, and detail time-series bucketing logic.",
        "updatedAt": "2026-01-31T15:24:08.130Z"
      },
      {
        "id": "15",
        "title": "Build Google Maps Scraper with Puppeteer MCP",
        "description": "Implement stealth Maps scraping using network interception to extract business data from JSON responses.",
        "details": "Create src/lead-discovery/maps-scraper.ts:\n1. MapsScraper class:\n   - Constructor receives PuppeteerClient instance\n2. Search execution:\n   - searchBusinesses(criteria: SearchCriteria): Promise<RawBusinessEntity[]>\n     * SearchCriteria: { query, location, radius, category }\n     * Navigate to Google Maps with search query\n     * Set up network interception for maps.googleapis.com responses\n     * Scroll to load more results (Locator-based waiting)\n     * Extract JSON data from intercepted responses\n3. Network interception pattern:\n   - page.on('response', async (response) => {...})\n   - Filter for URLs containing search results\n   - Parse JSON, extract business entities\n4. Scrolling with resilience:\n   - Use Locator API: page.locator('.business-list-item')\n   - Wait for visible with timeout (10s)\n   - Scroll container, wait for new items to load\n   - Stop when no new items appear\n5. Rate limiting:\n   - DELAY_BETWEEN_SCROLLS = 2000ms\n   - DELAY_BETWEEN_SEARCHES = 5000ms\n6. Stealth measures:\n   - Random delays between actions\n   - Human-like scrolling patterns\n   - User agent rotation\n7. RawBusinessEntity: name, address, phone, website, rating, reviewCount, placeId",
        "testStrategy": "Integration tests with real Maps searches (limited to avoid blocks). Test network interception captures expected data. Test scrolling loads additional results. Test rate limiting delays applied.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces for MapsScraper",
            "description": "Create TypeScript interfaces and types for SearchCriteria, RawBusinessEntity, and MapsScraper configuration.",
            "dependencies": [],
            "details": "Create src/lead-discovery/types.ts with:\n1. SearchCriteria interface: { query: string, location: string, radius?: number, category?: string }\n2. RawBusinessEntity interface: { name: string, address: string, phone: string | null, website: string | null, rating: number | null, reviewCount: number, placeId: string }\n3. MapsScraperConfig interface: { delayBetweenScrolls: number, delayBetweenSearches: number, maxScrollAttempts: number, scrollTimeout: number }\n4. Export all types for use across the module",
            "status": "pending",
            "testStrategy": "Create type tests to verify interface contracts. Ensure SearchCriteria enforces required query and location fields. Verify RawBusinessEntity matches expected Google Maps data structure.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement MapsScraper class with network interception",
            "description": "Build the core MapsScraper class with constructor, network response listener, and JSON data extraction from intercepted responses.",
            "dependencies": [
              1
            ],
            "details": "Create src/lead-discovery/maps-scraper.ts with:\n1. MapsScraper class constructor receiving PuppeteerClient instance\n2. Private responseBuffer array to collect intercepted data\n3. setupNetworkInterception() method:\n   - page.on('response', async handler) for maps.googleapis.com URLs\n   - Filter responses containing search result data\n   - Parse JSON and extract business entities matching RawBusinessEntity interface\n4. parseBusinessData(json: unknown): RawBusinessEntity[] helper to extract fields from nested Google Maps JSON structure\n5. Handle edge cases: missing fields, malformed responses, non-JSON responses",
            "status": "pending",
            "testStrategy": "Unit tests with mocked page responses. Test JSON parsing extracts correct fields. Test filters out non-search responses. Test handles malformed JSON gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement resilient scrolling with Locator API",
            "description": "Add scroll functionality using Puppeteer's Locator API with proper waiting, timeout handling, and detection of new results loading.",
            "dependencies": [
              2
            ],
            "details": "Add to MapsScraper class:\n1. scrollForMoreResults() method:\n   - Use page.locator('.business-list-item') or equivalent selector for Maps results\n   - await locator.waitFor({ state: 'visible', timeout: 10000 })\n   - Track count of visible items before/after scroll\n   - Scroll the results container using page.evaluate\n   - Wait for new items to load with locator.waitFor\n   - Return false when no new items appear (end of results)\n2. loadAllResults() method:\n   - Loop calling scrollForMoreResults until false returned or maxScrollAttempts reached\n   - Apply DELAY_BETWEEN_SCROLLS (2000ms) between each scroll\n   - Log progress (items loaded count)",
            "status": "pending",
            "testStrategy": "Integration tests verifying scroll triggers network requests. Test stops scrolling when no new items appear. Test respects maxScrollAttempts limit. Test timeout handling works correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add stealth measures and rate limiting",
            "description": "Implement anti-detection measures including random delays, human-like scrolling patterns, and user agent rotation.",
            "dependencies": [
              3
            ],
            "details": "Enhance MapsScraper with stealth features:\n1. StealthConfig: { userAgents: string[], minDelay: number, maxDelay: number }\n2. getRandomDelay(min: number, max: number): number - returns random ms between min/max\n3. getRandomUserAgent(): string - rotates through realistic browser user agents\n4. humanLikeScroll(page, distance): Promise<void>:\n   - Random scroll distance variance (20%)\n   - Random pause mid-scroll\n   - Occasional small reverse scrolls\n5. applyRateLimiting():\n   - DELAY_BETWEEN_SCROLLS = 2000ms + random(0-1000ms)\n   - DELAY_BETWEEN_SEARCHES = 5000ms + random(0-2000ms)\n6. Set random user agent before navigation",
            "status": "pending",
            "testStrategy": "Unit tests verify random delays are within configured ranges. Test user agent rotation cycles through list. Test human-like scroll includes variance. Measure actual delays match expected ranges.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement searchBusinesses main method",
            "description": "Build the primary searchBusinesses method that orchestrates navigation, network interception, scrolling, and returns extracted business data.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement searchBusinesses(criteria: SearchCriteria): Promise<RawBusinessEntity[]>:\n1. Build Google Maps search URL from criteria (query, location, radius, category)\n2. Set random user agent via stealth measures\n3. Call setupNetworkInterception() to begin capturing responses\n4. Navigate to Maps URL with waitUntil: 'networkidle0'\n5. Wait for initial results to render using Locator\n6. Call loadAllResults() to scroll and collect all businesses\n7. Apply DELAY_BETWEEN_SEARCHES before returning\n8. Deduplicate results by placeId\n9. Return aggregated RawBusinessEntity[] from responseBuffer\n10. Handle errors: navigation timeout, no results found, blocked by Google",
            "status": "pending",
            "testStrategy": "Integration tests with real Maps searches (limited count). Verify network interception captures expected data. Test scrolling loads additional results. Test rate limiting delays applied. Test deduplication by placeId.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail network interception patterns, scroll detection algorithms, and JSON response parsing selectors.",
        "updatedAt": "2026-01-30T23:27:21.526Z"
      },
      {
        "id": "16",
        "title": "Implement Business Data Extraction Pipeline",
        "description": "Parse and normalize business data from raw Maps responses into structured profiles.",
        "details": "Create src/lead-discovery/data-extractor.ts:\n1. DataExtractor class:\n   - Stateless utility class for data transformation\n2. Extraction methods:\n   - extractBusinessData(raw: RawBusinessEntity): BusinessProfile\n     * Map all fields from raw to structured format\n     * Handle missing fields gracefully (null vs undefined)\n3. Normalization:\n   - normalizePhoneNumber(phone: string | null): string | null\n     * Strip formatting, validate format\n     * Support US phone formats\n   - normalizeAddress(address: string): NormalizedAddress\n     * Parse into street, city, state, zip\n   - normalizeWebsiteUrl(url: string | null): string | null\n     * Ensure https:// prefix\n     * Remove trailing slashes\n     * Validate URL format\n4. Validation:\n   - validateBusinessProfile(profile: BusinessProfile): ValidationResult\n     * Check required fields present\n     * Check rating in valid range\n     * Validate URL format\n5. Batch processing:\n   - extractBatch(raws: RawBusinessEntity[]): BusinessProfile[]\n     * Filter out invalid entries\n     * Log extraction errors",
        "testStrategy": "Unit tests with mock Maps responses. Test phone number normalization formats. Test URL normalization edge cases. Test validation catches invalid data.",
        "priority": "high",
        "dependencies": [
          "5",
          "15"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DataExtractor Class Foundation and Type Definitions",
            "description": "Set up the stateless DataExtractor utility class with necessary type definitions for RawBusinessEntity, BusinessProfile, and NormalizedAddress interfaces.",
            "dependencies": [],
            "details": "Create src/lead-discovery/data-extractor.ts with the DataExtractor class structure. Define TypeScript interfaces: RawBusinessEntity (raw Maps response structure), BusinessProfile (normalized output), NormalizedAddress (street, city, state, zip), and ValidationResult (isValid, errors array). Export the class as a stateless utility with static methods for pure data transformation without side effects.",
            "status": "pending",
            "testStrategy": "Unit tests verify type definitions compile correctly. Test that DataExtractor can be instantiated and has all expected static methods available.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Core extractBusinessData Method",
            "description": "Build the main extraction method that maps raw Maps response data to structured BusinessProfile format with graceful handling of missing fields.",
            "dependencies": [
              1
            ],
            "details": "Implement extractBusinessData(raw: RawBusinessEntity): BusinessProfile method that maps fields: business_name, address, phone_number, website_url, rating, review_count, business_category. Handle null vs undefined semantics - use null for missing optional fields, never undefined. Apply defensive coding with optional chaining (?.) and nullish coalescing (??). Extract coordinates if available. Preserve original source data for auditing.",
            "status": "pending",
            "testStrategy": "Unit tests with mock Maps responses covering complete data, partial data, and minimal data scenarios. Test null handling for each optional field. Verify output matches BusinessProfile schema exactly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Normalization Utility Methods",
            "description": "Create phone number, address, and URL normalization functions to standardize data formats across all extracted business profiles.",
            "dependencies": [
              1
            ],
            "details": "Implement three normalization methods: 1) normalizePhoneNumber - strip formatting chars, validate US formats (10-digit, with/without +1), return null for invalid; 2) normalizeAddress - parse string into NormalizedAddress object using regex patterns for common US address formats, handle suite/apt numbers; 3) normalizeWebsiteUrl - ensure https:// prefix (upgrade http://), remove trailing slashes, strip query params, validate URL with URL constructor, return null for malformed URLs.",
            "status": "pending",
            "testStrategy": "Unit tests for phone: '(555) 123-4567'  '5551234567', '+1-555-123-4567'  '5551234567', invalid  null. URL tests: 'example.com'  'https://example.com', trailing slashes removed. Address tests verify parsing accuracy.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Profile Validation Logic",
            "description": "Build validation function to verify BusinessProfile data integrity, checking required fields, value ranges, and format compliance.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement validateBusinessProfile(profile: BusinessProfile): ValidationResult. Validation checks: 1) Required fields present: business_name (non-empty string), 2) Rating in valid range (0-5 if present), 3) URL format valid (passes URL constructor), 4) Phone format valid (10 digits after normalization), 5) Review count non-negative. Return ValidationResult with isValid boolean and errors array containing field-specific error messages. Support partial validation mode for optional fields.",
            "status": "pending",
            "testStrategy": "Test valid profiles pass. Test missing business_name fails. Test rating 6.0 fails range check. Test malformed URL fails format check. Test negative review_count fails. Verify error messages are descriptive.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Batch Processing with Error Handling",
            "description": "Create batch extraction method that processes multiple raw entities, filters invalid entries, and provides detailed logging for extraction failures.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement extractBatch(raws: RawBusinessEntity[]): BusinessProfile[] method. For each raw entity: 1) Attempt extraction via extractBusinessData, 2) Validate result via validateBusinessProfile, 3) Filter out invalid entries from final output. Implement error logging with console.warn for each failed extraction including raw entity identifier and specific validation errors. Return only valid BusinessProfiles. Add metrics tracking: total processed, successful, failed counts. Consider adding optional callback for error handling customization.",
            "status": "pending",
            "testStrategy": "Test batch with mix of valid/invalid entries returns only valid. Test error logging captures failure reasons. Test empty array input returns empty array. Test single invalid in batch still processes others. Verify extraction metrics accuracy.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create regex patterns for phone/address normalization, validation rule sets, and error categorization.",
        "updatedAt": "2026-01-31T04:55:41.345Z"
      },
      {
        "id": "17",
        "title": "Create Prospect Qualification Filter",
        "description": "Implement configurable qualification rules engine to score and filter prospects based on technical debt indicators.",
        "details": "Create src/lead-discovery/qualifier.ts:\n1. ProspectQualifier class:\n   - Constructor accepts QualificationRules configuration\n2. Qualification logic:\n   - qualifyProspect(profile: BusinessProfile, rules: QualificationRules): QualificationResult\n     * QualificationResult: { qualified: boolean, score: number, reasons: string[] }\n3. Default rules:\n   - MUST have website_url (fail reason: 'no_website')\n   - Rating < 4.0 = opportunity (add points, reason: 'low_rating')\n   - Review count < 20 = less competition (add points)\n   - Old-looking website indicators (if detectable from URL patterns)\n4. Scoring system:\n   - Base score: 50\n   - No website: score = 0, disqualify\n   - Low rating (<4.0): +20 points\n   - Low reviews (<20): +10 points\n   - Has website but no HTTPS: +15 points\n   - Score >= 50 = qualified\n5. Configurable thresholds:\n   - QualificationRules: { minScore, ratingThreshold, reviewThreshold }\n6. Batch qualification:\n   - qualifyBatch(profiles: BusinessProfile[], rules: QualificationRules): QualificationResult[]\n7. Filtering:\n   - filterQualified(profiles: BusinessProfile[], rules: QualificationRules): BusinessProfile[]",
        "testStrategy": "Unit tests with various business profiles. Test no-website disqualification. Test scoring calculation accuracy. Test configurable thresholds work.",
        "priority": "high",
        "dependencies": [
          "5",
          "16"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Types and QualificationRules Interface",
            "description": "Create TypeScript interfaces for BusinessProfile, QualificationRules, and QualificationResult in qualifier.ts.",
            "dependencies": [],
            "details": "Define QualificationRules with minScore: number, ratingThreshold: number, reviewThreshold: number. QualificationResult as { qualified: boolean, score: number, reasons: string[] }. Ensure BusinessProfile has website_url, rating, review_count properties.",
            "status": "pending",
            "testStrategy": "Unit test type validation with sample profiles matching and violating rules.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement ProspectQualifier Class Constructor",
            "description": "Create ProspectQualifier class with constructor accepting QualificationRules configuration.",
            "dependencies": [
              1
            ],
            "details": "Class stores rules as private property. Provide default rules if none passed: { minScore: 50, ratingThreshold: 4.0, reviewThreshold: 20 }. Validate input rules have required properties.",
            "status": "pending",
            "testStrategy": "Test constructor with valid/invalid rules sets defaults correctly and stores configuration.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement qualifyProspect Scoring Logic",
            "description": "Build qualifyProspect method with scoring system and default qualification rules.",
            "dependencies": [
              1,
              2
            ],
            "details": "Start with base score 50. Disqualify (score=0, 'no_website') if no website_url. Add +20 for rating < threshold ('low_rating'), +10 for reviews < threshold, +15 if website but no HTTPS. Return result with qualified = score >= minScore.",
            "status": "pending",
            "testStrategy": "Unit tests for all scoring scenarios: no website disqualification, low rating/reviews points, HTTPS check, threshold variations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Batch and Filter Methods",
            "description": "Implement qualifyBatch and filterQualified methods for array processing.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "qualifyBatch maps qualifyProspect over profiles array. filterQualified uses qualifyBatch and returns only qualified profiles (qualified: true). Both accept rules parameter for configurability.",
            "status": "pending",
            "testStrategy": "Test batch processing with mixed qualified/disqualified profiles. Verify filter returns correct subset.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Old Website Detection and Tests",
            "description": "Implement old-looking website detection from URL and write comprehensive unit tests.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add scoring rule for URL patterns indicating old sites (e.g., .htm, frameset, geocities patterns) with +10 points and 'old_tech' reason. Write tests covering all rules, edge cases, configurable thresholds.",
            "status": "pending",
            "testStrategy": "Unit tests for URL pattern detection. Full integration tests verifying end-to-end qualification pipeline with various BusinessProfile combinations.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define scoring formula weights, configurable rule sets, and edge case handling for qualification logic.",
        "updatedAt": "2026-01-31T04:56:54.410Z"
      },
      {
        "id": "18",
        "title": "Integrate Lead Discovery with Data Layer",
        "description": "Wire up discovery pipeline to persist qualified leads to the database with proper error handling.",
        "details": "Create src/lead-discovery/index.ts:\n1. LeadDiscoveryService class:\n   - Constructor receives MapsScraper, DataExtractor, ProspectQualifier, LeadRepository\n2. Main discovery flow:\n   - discoverLeads(criteria: SearchCriteria): Promise<DiscoveryResult>\n     * Call MapsScraper.searchBusinesses(criteria)\n     * Transform with DataExtractor.extractBatch()\n     * Filter with ProspectQualifier.filterQualified()\n     * Check duplicates with LeadRepository.findDuplicateByWebsite()\n     * Save new leads with LeadRepository.saveLeadsBatch()\n     * Return DiscoveryResult: { found, qualified, saved, duplicates }\n3. Error handling:\n   - Wrap scraper errors (rate limits, blocks) gracefully\n   - Continue on individual lead save failures\n   - Return partial results with error log\n4. Progress callbacks:\n   - onProgress?: (status: ProgressStatus) => void\n   - Report scraping, extraction, qualification, saving stages\n5. Configuration:\n   - maxLeadsPerSearch: number (default 100)\n   - deduplicateByWebsite: boolean (default true)\n6. Exported factory function:\n   - createLeadDiscoveryService(config: AppConfig): LeadDiscoveryService",
        "testStrategy": "End-to-end test from Maps search to database storage. Test duplicate detection prevents double-saves. Test partial success handling. Test progress callbacks fire.",
        "priority": "high",
        "dependencies": [
          "11",
          "15",
          "16",
          "17"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LeadDiscoveryService class structure",
            "description": "Implement the LeadDiscoveryService class constructor and basic properties including configuration options like maxLeadsPerSearch and deduplicateByWebsite.",
            "dependencies": [],
            "details": "Define class with constructor injecting MapsScraper, DataExtractor, ProspectQualifier, LeadRepository. Add private properties for config defaults: maxLeadsPerSearch=100, deduplicateByWebsite=true. Export factory function createLeadDiscoveryService(config: AppConfig).",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization and config defaults. Verify factory returns properly wired instance.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement core discoverLeads method pipeline",
            "description": "Build the main discovery flow in discoverLeads(criteria: SearchCriteria): Promise<DiscoveryResult> chaining all service calls.",
            "dependencies": [
              1
            ],
            "details": "Implement sequential calls: MapsScraper.searchBusinesses(criteria, {max: this.config.maxLeadsPerSearch}), DataExtractor.extractBatch(), ProspectQualifier.filterQualified(), LeadRepository.findDuplicateByWebsite() for dedup if enabled, LeadRepository.saveLeadsBatch(newLeads). Return {found, qualified, saved, duplicates}.",
            "status": "pending",
            "testStrategy": "Mock all dependencies. Test full happy path returns correct DiscoveryResult counts. Verify maxLeads limit applied.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add comprehensive error handling",
            "description": "Wrap pipeline steps with try-catch for scraper errors, individual save failures, and return partial results with error logging.",
            "dependencies": [
              2
            ],
            "details": "Use try-catch around scraper/extractor/qualifier. Log errors with structured details (stage, count failed). Continue on per-lead save errors, count partial saves. Gracefully handle rate limits/blocks by retrying or skipping.",
            "status": "pending",
            "testStrategy": "Integration tests simulating scraper failures, save errors. Verify partial results returned with accurate counts and logs.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement progress callbacks",
            "description": "Add onProgress callback support reporting status at each pipeline stage: scraping, extraction, qualification, dedup, saving.",
            "dependencies": [
              2
            ],
            "details": "Define ProgressStatus interface {stage: string, count: number, total: number}. Call onProgress if provided at key points: after search (scraping), extract (extraction), filter (qualification), dedup (duplicates), save (persisted).",
            "status": "pending",
            "testStrategy": "Unit tests verify callback fires with correct stage/count data at each step. Test with mock callback capturing calls.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add types, exports, and integration tests",
            "description": "Define all required interfaces and run end-to-end tests from search to database persistence.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create interfaces: SearchCriteria, DiscoveryResult {found: number, qualified: number, saved: number, duplicates: number}, ProgressStatus. Export service and factory from index.ts. Write E2E tests for duplicate prevention, partial success, progress firing.",
            "status": "pending",
            "testStrategy": "End-to-end tests: full pipeline with real deps, duplicate detection blocks saves, partial failure scenarios, progress callback verification.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement pipeline error boundaries, progress reporting hooks, and partial result handling strategies.",
        "updatedAt": "2026-01-31T12:49:22.803Z"
      },
      {
        "id": "19",
        "title": "Integrate Lighthouse for Performance Analysis",
        "description": "Build performance analysis module using Chrome DevTools Protocol for Core Web Vitals and code coverage metrics.",
        "details": "Create src/audit-engine/performance.ts:\n1. PerformanceAnalyzer class:\n   - Constructor receives PuppeteerClient instance\n2. Core analysis:\n   - analyzePerformance(url: string, options?: AnalysisOptions): Promise<PerformanceReport>\n     * Run Lighthouse CI audit via Chrome DevTools Protocol\n     * Extract Core Web Vitals: FCP, LCP, CLS, INP\n     * Calculate overall performance score (0-100)\n3. Code coverage analysis:\n   - await page.coverage.startJSCoverage()\n   - await page.coverage.startCSSCoverage()\n   - Navigate and wait for networkidle\n   - Stop coverage, calculate unused percentages\n   - unusedJS, unusedCSS as percentage values\n4. PerformanceReport type:\n   - score, fcp, lcp, cls, inp\n   - unusedCodePercent: { js: number, css: number }\n   - loadTime (total navigation time in ms)\n   - resourceCount, totalTransferSize\n5. Thresholds for pain points:\n   - LCP > 2500ms = 'SLOW_LOAD' pain point\n   - CLS > 0.1 = 'LAYOUT_SHIFT' pain point\n   - Unused code > 50% = 'CODE_BLOAT' pain point\n6. Options:\n   - viewport: 'mobile' | 'desktop'\n   - throttling: boolean (simulate 3G)\n   - timeout: number (default 60s)",
        "testStrategy": "Integration tests with known slow/fast websites. Verify metric ranges are accurate. Test code coverage calculation. Test timeout handling for unresponsive sites.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define PerformanceAnalyzer class and types",
            "description": "Create the PerformanceAnalyzer class constructor and define TypeScript interfaces for AnalysisOptions and PerformanceReport including all required fields.",
            "dependencies": [],
            "details": "In src/audit-engine/performance.ts: Define PerformanceAnalyzer class with PuppeteerClient constructor param. Create AnalysisOptions (viewport, throttling, timeout) and PerformanceReport interfaces with score, fcp, lcp, cls, inp, unusedCodePercent {js, css}, loadTime, resourceCount, totalTransferSize.",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization and type validation with sample PuppeteerClient mock.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Lighthouse CI audit via CDP",
            "description": "Integrate Lighthouse using Chrome DevTools Protocol to run performance audits and extract Core Web Vitals metrics (FCP, LCP, CLS, INP).",
            "dependencies": [
              1
            ],
            "details": "In analyzePerformance(): Launch CDP session with puppeteer, run lighthouse('performance') audit with options for viewport/throttling, parse results to extract FCP, LCP, CLS, INP values, handle timeout with options.timeout (default 60s).",
            "status": "pending",
            "testStrategy": "Integration test with test URL verifies Core Web Vitals extraction matches expected ranges from known sites.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add code coverage collection and calculation",
            "description": "Implement JS and CSS coverage tracking using Puppeteer coverage API and calculate unused percentages.",
            "dependencies": [
              1,
              2
            ],
            "details": "In analyzePerformance(): Before navigation call page.coverage.startJSCoverage() and startCSSCoverage(), navigate to URL and wait for networkidle0, then stop coverage, compute unusedJS and unusedCSS percentages from coverage data.",
            "status": "pending",
            "testStrategy": "Unit test coverage percentage calculation with mock coverage data; integration test verifies >0% unused on test pages.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Calculate performance score, load time, and resources",
            "description": "Compute overall performance score (0-100), capture loadTime, resourceCount, and totalTransferSize from audit results.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Aggregate Lighthouse performance score directly or weighted average of vitals, measure loadTime as navigation end timestamp, collect resourceCount and totalTransferSize from PerformanceObserver or network logs.",
            "status": "pending",
            "testStrategy": "Verify score calculation formula with known Lighthouse outputs; test resource metrics match DevTools network panel.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement pain point detection and finalize method",
            "description": "Apply thresholds to detect pain points (SLOW_LOAD, LAYOUT_SHIFT, CODE_BLOAT) and complete analyzePerformance method return.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Check LCP > 2500ms  'SLOW_LOAD', CLS > 0.1  'LAYOUT_SHIFT', unusedJS/CSS > 50%  'CODE_BLOAT', include painPoints array in PerformanceReport, ensure full method returns Promise<PerformanceReport> with all fields.",
            "status": "pending",
            "testStrategy": "Test threshold logic with boundary values; end-to-end test with slow/heavy sites verifies pain points and full report structure.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Configure Lighthouse CDP categories, coverage collection timing, and performance score calculation weights.",
        "updatedAt": "2026-01-30T23:33:25.110Z"
      },
      {
        "id": "20",
        "title": "Build Accessibility Compliance Scanner",
        "description": "Implement WCAG violation detection using accessibility tree inspection and automated checks.",
        "details": "Create src/audit-engine/accessibility.ts:\n1. AccessibilityScanner class:\n   - Constructor receives PuppeteerClient instance\n2. Accessibility tree inspection:\n   - scanAccessibility(url: string, level: 'A' | 'AA' | 'AAA'): Promise<AccessibilityReport>\n   - Get accessibility tree: await page.accessibility.snapshot()\n   - Traverse tree to find violations\n3. Violation detection:\n   - Images without alt text (role: 'img', name: '')\n   - Buttons without labels (role: 'button', name: '')\n   - Form inputs without labels\n   - Low contrast text (requires style inspection)\n   - Missing landmark regions\n   - Keyboard navigation issues\n4. WCAG mapping:\n   - Map each violation to WCAG criterion (e.g., 1.1.1 for alt text)\n   - Assign severity: critical, serious, moderate, minor\n   - Provide remediation recommendation\n5. AccessibilityReport type:\n   - score (0-100 based on violation count/severity)\n   - violations: WCAGViolation[]\n   - passedChecks: string[]\n   - level: 'A' | 'AA' | 'AAA'\n6. Legal risk assessment:\n   - highRiskViolations = violations.filter(v => v.severity === 'critical')\n   - legalRiskScore based on critical violations count",
        "testStrategy": "Integration tests with sites having known violations. Verify detection accuracy against manual audit. Test WCAG mapping correctness. Test severity assignment.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AccessibilityScanner Class and Types",
            "description": "Define the AccessibilityScanner class constructor and all required TypeScript types including AccessibilityReport and WCAGViolation.",
            "dependencies": [],
            "details": "In src/audit-engine/accessibility.ts: Export AccessibilityReport type with score, violations[], passedChecks[], level; WCAGViolation with criterion, severity, description, recommendation; Constructor takes PuppeteerClient; Add scanAccessibility method signature.",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization and type validation with sample PuppeteerClient mock.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Accessibility Tree Snapshot and Traversal",
            "description": "Add method to capture page accessibility tree using page.accessibility.snapshot() and implement recursive tree traversal utility.",
            "dependencies": [
              1
            ],
            "details": "Create getAccessibilityTree(page) => Promise<AccessibilityNode>; Implement traverseTree(node, callback) to visit all nodes; Handle tree structure with children array and properties like role, name.",
            "status": "pending",
            "testStrategy": "Unit test tree capture on sample HTML; Verify traversal visits all expected nodes with correct role/name properties.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Core Violation Detectors",
            "description": "Create detectors for images without alt text, buttons without labels, form inputs without labels, and missing landmark regions using tree traversal.",
            "dependencies": [
              2
            ],
            "details": "Write isImageWithoutAlt(node), isButtonWithoutLabel(node), isInputWithoutLabel(node), hasSufficientLandmarks(tree); Use role checks: 'img' with empty name, 'button' empty name, 'textbox'/'combobox' etc without associated label.",
            "status": "pending",
            "testStrategy": "Integration tests with Puppeteer on pages with/without violations; Verify exact violation counts match manual inspection.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Advanced Checks and WCAG Mapping",
            "description": "Implement low contrast detection, keyboard issues, WCAG criterion mapping, severity assignment, and remediation recommendations.",
            "dependencies": [
              3
            ],
            "details": "Stub lowContrastCheck (note: requires evaluate for computed styles); Basic keyboard trap detection; Map violations: img=>1.1.1, button=>4.1.2 etc.; Severity: critical for no-label interactive, serious for no-alt; Add recommendation strings.",
            "status": "pending",
            "testStrategy": "Unit tests for mapping functions; Integration tests verify correct WCAG codes and severities on test pages.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Report Generation and Legal Risk Assessment",
            "description": "Calculate accessibility score, filter high-risk violations, compute legalRiskScore, and complete scanAccessibility method integration.",
            "dependencies": [
              4
            ],
            "details": "Score = 100 - (critical*20 + serious*10 + moderate*5 + minor*1); highRiskViolations = filter severity==='critical'; legalRiskScore = highRiskViolations.length * 25; Integrate all detectors in scanAccessibility; Handle WCAG levels A/AA/AAA filtering.",
            "status": "pending",
            "testStrategy": "End-to-end tests on sites with known violations; Verify score calculation, risk assessment, and report structure matches expected output.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define accessibility tree traversal algorithms, WCAG rule mappings, and severity scoring formulas.",
        "updatedAt": "2026-01-31T04:11:45.066Z"
      },
      {
        "id": "21",
        "title": "Implement Visual Evidence Capture System",
        "description": "Build screenshot and video recording capabilities for documenting technical issues.",
        "details": "Create src/audit-engine/evidence.ts:\n1. EvidenceCapture class:\n   - Constructor receives PuppeteerClient instance\n2. Screenshot capture:\n   - captureScreenshot(url: string, viewport: ViewportConfig): Promise<Buffer>\n     * Set viewport (default: iPhone X 375x812 for mobile)\n     * Wait for page load\n     * Capture full page or viewport only\n   - captureAnnotatedScreenshot(url: string, issues: Issue[]): Promise<Buffer>\n     * Capture screenshot\n     * Draw red boxes/arrows pointing to issue locations\n     * Use canvas or image manipulation library\n3. Video recording:\n   - recordPageLoad(url: string, duration: number): Promise<Buffer>\n     * Use page.tracing.start({ screenshots: true })\n     * Navigate to page\n     * Stop tracing after load or timeout\n     * If load time > 3s, compile frames to WebM video\n   - Use ScreenRecorder API if available, else frame-by-frame capture\n4. Viewport configurations:\n   - MOBILE_VIEWPORT: { width: 375, height: 812, isMobile: true }\n   - TABLET_VIEWPORT: { width: 768, height: 1024, isMobile: true }\n   - DESKTOP_VIEWPORT: { width: 1920, height: 1080, isMobile: false }\n5. Output formats:\n   - Screenshots: PNG (default), JPEG (for smaller size)\n   - Videos: WebM (primary), MP4 (fallback)",
        "testStrategy": "Integration tests capture screenshots at various viewports. Test video recording produces valid WebM. Test annotation renders correctly on screenshot.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create EvidenceCapture class with constructor and viewport configs",
            "description": "Implement the EvidenceCapture class constructor that receives PuppeteerClient and define MOBILE_VIEWPORT, TABLET_VIEWPORT, DESKTOP_VIEWPORT constants.",
            "dependencies": [],
            "details": "In src/audit-engine/evidence.ts, export class EvidenceCapture { constructor(private puppeteerClient: PuppeteerClient) {} } and define the three viewport objects as class properties or constants. Use TypeScript interfaces for ViewportConfig.",
            "status": "pending",
            "testStrategy": "Unit test constructor initializes without errors and viewport configs match expected dimensions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement captureScreenshot method",
            "description": "Build the basic screenshot capture functionality with viewport setting, page load wait, and PNG buffer return.",
            "dependencies": [
              1
            ],
            "details": "Implement async captureScreenshot(url: string, viewport?: ViewportConfig): Promise<Buffer> using page.setViewport(), page.goto(url, {waitUntil: 'networkidle0'}), and page.screenshot({type: 'png'}). Default to MOBILE_VIEWPORT if no viewport provided. Return Buffer directly.",
            "status": "pending",
            "testStrategy": "Integration test captures screenshot of test page at mobile viewport and verifies Buffer is PNG format.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add captureAnnotatedScreenshot with issue annotations",
            "description": "Extend screenshot capture to draw red boxes and arrows on detected issues using canvas manipulation.",
            "dependencies": [
              2
            ],
            "details": "First call captureScreenshot, then use sharp or canvas library to overlay red rectangles at issue coordinates and arrows pointing to them. Issues array provides selector or bounding box data. Return annotated PNG Buffer.",
            "status": "pending",
            "testStrategy": "Test renders red boxes correctly around mock issue elements and produces valid annotated PNG buffer.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement recordPageLoad video recording method",
            "description": "Create video recording using Puppeteer tracing with screenshots or frame capture, compiling to WebM buffer.",
            "dependencies": [
              1
            ],
            "details": "Use page.tracing.start({screenshots: true, screenshotsPath: tempDir}), page.goto(url), wait for load/timeout, page.tracing.stop(). If load >3s, extract screenshot frames and compile to WebM using ffmpeg or similar. Fallback to frame-by-frame page.screenshot().",
            "status": "pending",
            "testStrategy": "Test produces valid WebM buffer playable in browser; verify frame extraction when load exceeds 3s.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add JPEG output support and export all methods",
            "description": "Complete implementation with JPEG format option and proper TypeScript exports/interfaces.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Add optional format parameter to screenshot methods ('png'|'jpeg'). Use page.screenshot({type: format, quality: 90}) for JPEG. Export all methods, define Issue and ViewportConfig interfaces. Add JSDoc documentation.",
            "status": "pending",
            "testStrategy": "Integration tests verify both PNG and JPEG outputs are valid images; full class integration test with all methods.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Specify canvas annotation algorithms, video frame extraction timing, and format conversion logic.",
        "updatedAt": "2026-01-31T04:14:47.253Z"
      },
      {
        "id": "22",
        "title": "Create Mobile Responsiveness Analyzer",
        "description": "Test website layouts across device viewports to identify responsive design failures.",
        "details": "Create src/audit-engine/responsive.ts:\n1. ResponsivenessAnalyzer class:\n   - Constructor receives PuppeteerClient, EvidenceCapture\n2. Multi-viewport testing:\n   - analyzeResponsiveness(url: string): Promise<ResponsivenessReport>\n   - Test viewports: mobile (375px), tablet (768px), desktop (1920px)\n   - For each viewport:\n     * Set viewport\n     * Check for horizontal overflow (scrollWidth > viewport.width)\n     * Detect layout shifts between sizes\n     * Capture screenshot\n3. Issue detection:\n   - HORIZONTAL_OVERFLOW: document.body.scrollWidth > window.innerWidth\n   - TOUCH_TARGET_SIZE: buttons/links < 44x44px on mobile\n   - TEXT_TOO_SMALL: font-size < 12px on mobile\n   - OVERLAPPING_ELEMENTS: elements with negative margins causing overlap\n4. ResponsivenessReport type:\n   - score (0-100)\n   - issues: ResponsiveIssue[]\n   - screenshotsByViewport: { mobile: Buffer, tablet: Buffer, desktop: Buffer }\n5. ResponsiveIssue type:\n   - type, viewport, description, element (selector), screenshot\n6. Comparison:\n   - generateComparisonImage(mobile: Buffer, desktop: Buffer): Buffer\n   - Side-by-side comparison image for evidence",
        "testStrategy": "Integration tests with responsive and non-responsive sites. Verify overflow detection. Test touch target size calculation. Test comparison image generation.",
        "priority": "medium",
        "dependencies": [
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define ResponsivenessAnalyzer class and types",
            "description": "Create the ResponsivenessAnalyzer class constructor and define TypeScript interfaces for ResponsivenessReport and ResponsiveIssue.",
            "dependencies": [],
            "details": "Implement constructor accepting PuppeteerClient and EvidenceCapture. Define ResponsivenessReport with score (0-100), issues array, screenshotsByViewport object. Define ResponsiveIssue with type, viewport, description, element selector, screenshot buffer.",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization and type validation with sample data.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement multi-viewport testing logic",
            "description": "Add analyzeResponsiveness method to test mobile (375px), tablet (768px), desktop (1920px) viewports with screenshot capture.",
            "dependencies": [
              1
            ],
            "details": "Use PuppeteerClient to set viewport sizes, navigate to URL, capture screenshots via EvidenceCapture for each viewport, store in screenshotsByViewport map.",
            "status": "pending",
            "testStrategy": "Integration test verifies screenshots captured for all three viewports with correct dimensions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement horizontal overflow detection",
            "description": "Add logic to detect HORIZONTAL_OVERFLOW issue by comparing document.body.scrollWidth > window.innerWidth for each viewport.",
            "dependencies": [
              2
            ],
            "details": "Inject JavaScript via Puppeteer to measure scrollWidth and innerWidth, create ResponsiveIssue if overflow detected, include element selector and viewport screenshot.",
            "status": "pending",
            "testStrategy": "Test with sites having overflow (e.g., fixed-width elements) and responsive sites to verify detection accuracy.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement touch target and text size checks",
            "description": "Add detection for TOUCH_TARGET_SIZE (<44x44px buttons/links on mobile) and TEXT_TOO_SMALL (<12px font-size on mobile viewport).",
            "dependencies": [
              2
            ],
            "details": "Query buttons/links with getBoundingClientRect() for size checks on mobile viewport only. Query computed font-size styles for text elements. Log issues with selectors and descriptions.",
            "status": "pending",
            "testStrategy": "Unit tests mock element dimensions and font sizes. Integration tests with sample pages verify issue reporting.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add layout shift detection, scoring, and comparison",
            "description": "Implement layout shift detection between viewports, calculate overall score, and generate side-by-side comparison images.",
            "dependencies": [
              3,
              4
            ],
            "details": "Compare element positions/sizes between mobile/desktop screenshots for shifts. Compute score based on issue count/severity. Implement generateComparisonImage for side-by-side Buffer output.",
            "status": "pending",
            "testStrategy": "Integration tests verify score calculation (0-100 range), layout shift detection, and comparison image generation with valid Buffer output.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define viewport breakpoint logic, touch target measurement algorithms, and layout shift detection.",
        "updatedAt": "2026-01-31T12:52:31.192Z"
      },
      {
        "id": "23",
        "title": "Integrate Audit Engine with Data Layer",
        "description": "Wire up audit components to persist results and evidence to the database.",
        "details": "Create src/audit-engine/index.ts:\n1. AuditService class:\n   - Constructor receives all analyzer instances + LeadRepository + EvidenceStore\n2. Full audit flow:\n   - runAudit(leadId: string): Promise<AuditResult>\n     * Get lead from repository\n     * Run performance analysis\n     * Run accessibility scan\n     * Run responsiveness analysis\n     * Capture evidence (screenshots, video if slow)\n     * Upload evidence to storage\n     * Save audit result with evidence URLs\n     * Update lead with audit status\n3. Partial audits:\n   - runPerformanceOnly(leadId: string): Promise<Partial<AuditResult>>\n   - runAccessibilityOnly(leadId: string): Promise<Partial<AuditResult>>\n4. Batch processing:\n   - runBatchAudit(leadIds: string[], options: BatchOptions): Promise<BatchAuditResult>\n   - Parallel processing using BrowserContexts (configurable concurrency)\n   - Progress reporting\n5. Error handling:\n   - Handle blocked sites (return partial audit, flag as 'blocked')\n   - Handle timeouts (return partial results)\n   - Continue batch on individual failures\n6. Pain point aggregation:\n   - aggregatePainPoints(audit: AuditResult): PainPoint[]\n   - Combine performance, accessibility, responsive issues into unified list",
        "testStrategy": "End-to-end test from URL to stored audit + evidence. Test batch processing with concurrency. Test partial audit handling. Test evidence URLs are accessible.",
        "priority": "high",
        "dependencies": [
          "11",
          "13",
          "19",
          "20",
          "21",
          "22"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AuditService Class with Constructor",
            "description": "Implement the AuditService class constructor that receives analyzer instances, LeadRepository, and EvidenceStore dependencies.",
            "dependencies": [],
            "details": "Define AuditService class in src/audit-engine/index.ts with private readonly properties for PerformanceAnalyzer, AccessibilityAnalyzer, ResponsivenessAnalyzer, LeadRepository, and EvidenceStore. Implement dependency injection via constructor parameters.",
            "status": "pending",
            "testStrategy": "Unit test constructor with mocked dependencies to verify proper initialization and type safety.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Full Audit Flow in runAudit Method",
            "description": "Build the complete runAudit(leadId: string) method orchestrating lead retrieval, all analyses, evidence capture, storage, and lead status update.",
            "dependencies": [
              1
            ],
            "details": "Sequence operations: fetch lead, run performance/accessibility/responsiveness analyses, capture screenshots/video, upload to EvidenceStore, persist AuditResult with evidence URLs, update lead status to AUDITED.",
            "status": "pending",
            "testStrategy": "Integration test with mocked analyzers and repos verifying full flow produces complete AuditResult and updates lead status.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Partial Audit Methods",
            "description": "Implement runPerformanceOnly and runAccessibilityOnly methods returning Partial<AuditResult> for targeted audits.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create runPerformanceOnly to execute only performance analysis and evidence capture. Create runAccessibilityOnly for accessibility scan only. Both save partial results and update lead with partial audit status.",
            "status": "pending",
            "testStrategy": "Unit tests verifying each method runs only specified analyzer and produces partial AuditResult with correct fields populated.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop Batch Processing with runBatchAudit",
            "description": "Implement runBatchAudit(leadIds: string[], options: BatchOptions) with parallel processing, configurable concurrency, and progress reporting.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use Promise.allSettled with p-limit for concurrency control via BrowserContexts. Track progress with callback. Handle individual failures gracefully while continuing batch. Return BatchAuditResult with successes/failures.",
            "status": "pending",
            "testStrategy": "E2E test with 5-10 mock leads verifying parallel execution, concurrency limits, progress callbacks, and mixed success/failure handling.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Error Handling and Pain Point Aggregation",
            "description": "Add comprehensive error handling for blocked sites/timeouts and implement aggregatePainPoints method to unify issues across analyses.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Wrap analysis calls in try-catch for blocked/timeout detection, returning partial results with flags. Implement aggregatePainPoints to merge performance, accessibility, responsive issues into unified PainPoint[] array with severity prioritization.",
            "status": "pending",
            "testStrategy": "Unit tests for error scenarios (mock blocked sites/timeouts) verifying partial results. Integration test for pain point aggregation across full audit results.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail audit orchestration sequence, partial result merging logic, and batch concurrency controls.",
        "updatedAt": "2026-01-31T14:15:13.617Z"
      },
      {
        "id": "24",
        "title": "Build Email Template Engine",
        "description": "Create dynamic email template system that injects audit findings and evidence into personalized content.",
        "details": "Create src/email-automation/template-engine.ts:\n1. TemplateEngine class:\n   - Constructor receives template configuration\n2. Template rendering:\n   - renderEmail(templateId: string, context: EmailContext): RenderedEmail\n   - EmailContext: { lead: LeadProfile, audit: AuditResult, calendarLink: string }\n   - RenderedEmail: { subject: string, html: string, text: string }\n3. Variable substitution:\n   - {{business_name}} -> lead.business_name\n   - {{performance_score}} -> audit.performance_score\n   - {{load_time}} -> audit.fcp formatted as '3.2 seconds'\n   - {{top_issue}} -> highest severity pain point description\n   - {{evidence_link}} -> first evidence URL\n   - {{calendar_link}} -> booking link\n4. Conditional blocks:\n   - {{#if slow_load}}Your site takes {{load_time}} to load{{/if}}\n   - Use handlebars-style syntax\n5. Template storage:\n   - Store templates in database or filesystem\n   - getTemplate(id: string): Promise<EmailTemplate>\n   - saveTemplate(template: EmailTemplate): Promise<void>\n6. Default templates:\n   - initial_outreach: First contact with key finding\n   - followup_1: Reminder with additional evidence\n   - followup_2: Last chance with urgency\n7. Tone customization:\n   - adjustTone(content: string, severity: 'urgent' | 'normal' | 'friendly'): string",
        "testStrategy": "Unit tests with templates + mock context. Test all variable substitutions. Test conditional blocks render correctly. Test missing variable handling.",
        "priority": "high",
        "dependencies": [
          "5",
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript interfaces and create TemplateEngine class",
            "description": "Create all necessary TypeScript interfaces for EmailContext, RenderedEmail, EmailTemplate and implement TemplateEngine class constructor that receives template configuration.",
            "dependencies": [],
            "details": "Define interfaces: EmailContext { lead: LeadProfile, audit: AuditResult, calendarLink: string }, RenderedEmail { subject: string, html: string, text: string }, EmailTemplate { id: string, subject: string, html: string, text: string }. Implement constructor with config storage setup.",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization with valid/invalid config. Verify interfaces compile without TypeScript errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement template storage with getTemplate and saveTemplate methods",
            "description": "Add getTemplate(id: string): Promise<EmailTemplate> and saveTemplate(template: EmailTemplate): Promise<void> methods supporting database or filesystem storage.",
            "dependencies": [
              1
            ],
            "details": "Implement async methods using Supabase storage or local JSON files. Handle template loading/saving with error handling for missing templates. Create default template directory structure.",
            "status": "pending",
            "testStrategy": "Unit tests for template save/load cycles. Test missing template returns null. Test concurrent access handling.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build variable substitution and context mapping logic",
            "description": "Implement variable replacement logic mapping {{business_name}}, {{performance_score}}, {{load_time}}, {{top_issue}}, {{evidence_link}}, {{calendar_link}} to EmailContext properties.",
            "dependencies": [
              1
            ],
            "details": "Create helper functions for formatting (load_time as 'X.X seconds'), finding highest severity issue, extracting first evidence URL. Support safe fallbacks for missing data.",
            "status": "pending",
            "testStrategy": "Unit tests for each variable substitution with mock context. Test formatting functions. Test graceful handling of missing context properties.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Handlebars template engine with conditional blocks",
            "description": "Install and configure Handlebars for renderEmail method supporting {{#if slow_load}} conditional blocks and all variable substitutions.",
            "dependencies": [
              2,
              3
            ],
            "details": "Register custom Handlebars helpers for audit conditions (slow_load, high_bounce, etc.). Implement renderEmail(templateId: string, context: EmailContext): RenderedEmail that loads template, compiles, and renders both HTML and plain text versions.",
            "status": "pending",
            "testStrategy": "Unit tests rendering templates with conditional blocks. Test if/else logic with various audit results. Verify both HTML and text outputs.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add default templates and tone customization functionality",
            "description": "Create initial_outreach, followup_1, followup_2 default templates and implement adjustTone(content: string, severity: 'urgent'|'normal'|'friendly'): string method.",
            "dependencies": [
              2,
              4
            ],
            "details": "Seed database/filesystem with 3 default templates containing all variables and conditionals. Implement tone adjustment using word replacement lists (urgent: 'critical/urgent', friendly: 'helpful/suggestion'). Integrate into render pipeline.",
            "status": "pending",
            "testStrategy": "Integration tests rendering all default templates with mock data. Test tone variations produce expected word substitutions. Test full renderEmail pipeline end-to-end.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement Handlebars helper functions, variable resolution precedence, and template validation rules.",
        "updatedAt": "2026-01-31T13:13:14.534Z"
      },
      {
        "id": "25",
        "title": "Implement Email Campaign Orchestrator",
        "description": "Build campaign management system with multi-step sequences, scheduling, and follow-up automation.",
        "details": "Create src/email-automation/campaign-manager.ts:\n1. CampaignManager class:\n   - Constructor receives MailgunClient, LeadRepository, StatusTracker, TemplateEngine\n2. Campaign execution:\n   - executeCampaign(campaignId: string): Promise<CampaignExecutionResult>\n     * Fetch campaign config and eligible leads\n     * For each lead: render template, send via Mailgun\n     * Update lead status to 'contacted'\n     * Schedule follow-ups based on sequence\n3. Sequence management:\n   - scheduleFollowUp(leadId: string, step: EmailSequenceStep): Promise<void>\n     * Calculate send time based on delay_days\n     * Store scheduled send in database\n   - processScheduledEmails(): Promise<void> (cron job)\n     * Find due emails\n     * Check send_condition (if_no_reply, if_no_open)\n     * Send if condition met, skip if already replied\n4. Capacity management:\n   - Daily send limit per campaign\n   - Distribute sends throughout day\n   - Respect Mailgun rate limits\n5. Campaign lifecycle:\n   - createCampaign(config: CampaignConfig): Promise<Campaign>\n   - pauseCampaign(id: string): Promise<void>\n   - resumeCampaign(id: string): Promise<void>\n   - stopCampaign(id: string): Promise<void>\n6. Lead filtering:\n   - Filter by qualification score, category, status\n   - Exclude recently contacted leads",
        "testStrategy": "Integration tests with Mailgun sandbox. Test campaign sends to correct leads. Test follow-up scheduling. Test send conditions evaluated correctly. Test capacity limits.",
        "priority": "high",
        "dependencies": [
          "8",
          "11",
          "12",
          "24"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CampaignManager Class Constructor and Core Structure",
            "description": "Create the CampaignManager class in src/email-automation/campaign-manager.ts with constructor that receives MailgunClient, LeadRepository, StatusTracker, and TemplateEngine dependencies.",
            "dependencies": [],
            "details": "Define class with private readonly properties for injected dependencies. Add TypeScript interfaces for all dependencies if not already defined. Implement proper dependency injection pattern.",
            "status": "pending",
            "testStrategy": "Unit test constructor validates dependencies are provided and stores them correctly. Test TypeScript type safety.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement executeCampaign Method with Lead Processing",
            "description": "Build executeCampaign(campaignId: string) method to fetch campaign config, filter eligible leads, render/send emails via Mailgun, update statuses, and schedule follow-ups.",
            "dependencies": [
              1
            ],
            "details": "Fetch campaign from repo, apply lead filters (score, category, status, exclude recent), batch process leads with template rendering and Mailgun send, update 'contacted' status, call scheduleFollowUp for sequences.",
            "status": "pending",
            "testStrategy": "Integration test with mock Mailgun sandbox: verify correct leads filtered, emails rendered/sent, statuses updated, follow-ups scheduled.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Sequence Management Methods",
            "description": "Add scheduleFollowUp(leadId: string, step: EmailSequenceStep) and processScheduledEmails() methods for follow-up scheduling and cron-based processing with conditions.",
            "dependencies": [
              1
            ],
            "details": "scheduleFollowUp calculates send time from delay_days and stores in DB. processScheduledEmails finds due emails, evaluates send_condition (if_no_reply, if_no_open), sends if met, skips if replied.",
            "status": "pending",
            "testStrategy": "Unit tests for delay calculation and condition logic. Integration tests verify cron processes due emails correctly with/without conditions met.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Capacity Management and Rate Limiting",
            "description": "Implement daily send limits per campaign, distribute sends throughout the day, and respect Mailgun rate limits in executeCampaign and processScheduledEmails.",
            "dependencies": [
              2
            ],
            "details": "Track daily sends per campaign in StatusTracker, implement batching/throttling with delays, queue sends to avoid rate limits, exponential backoff for failures.",
            "status": "pending",
            "testStrategy": "Load tests simulate high volume: verify limits respected, even distribution, no rate limit violations, graceful degradation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Campaign Lifecycle and Lead Filtering Methods",
            "description": "Add createCampaign, pause/resume/stopCampaign methods plus comprehensive lead filtering logic by qualification score, category, status, and recent contacts.",
            "dependencies": [
              1
            ],
            "details": "CRUD operations for campaigns with pause/resume/stop states. Lead filter combines score thresholds, categories, statuses, and exclusion window (e.g., 30 days). Integrate into executeCampaign.",
            "status": "pending",
            "testStrategy": "Integration tests verify lifecycle states prevent/block actions correctly. Test filtering excludes correct leads, includes qualified ones across all criteria.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define sequence state machine, condition evaluation logic, and capacity throttling algorithms.",
        "updatedAt": "2026-01-31T13:56:33.072Z"
      },
      {
        "id": "26",
        "title": "Create Email Delivery Tracker",
        "description": "Implement webhook handling for email events and engagement metric tracking.",
        "details": "Create src/email-automation/delivery-tracker.ts:\n1. DeliveryTracker class:\n   - Constructor receives MailgunClient, LeadRepository, StatusTracker\n2. Webhook processing:\n   - processWebhook(payload: unknown): Promise<void>\n     * Parse and validate webhook with MailgunClient.parseWebhook()\n     * Route to appropriate handler based on event type\n3. Event handlers:\n   - handleDelivered(event: DeliveredEvent): Promise<void>\n   - handleOpened(event: OpenedEvent): Promise<void>\n   - handleClicked(event: ClickedEvent): Promise<void>\n   - handleBounced(event: BouncedEvent): Promise<void>\n     * Mark lead as invalid_email if hard bounce\n   - handleReplied(event: RepliedEvent): Promise<void>\n     * Update lead status to 'responded'\n     * Halt follow-up sequence\n4. Event storage:\n   - Save all events to email_events table\n   - Link to lead and campaign\n5. Aggregation:\n   - getEmailMetrics(campaignId: string): Promise<EmailMetrics>\n     * sent, delivered, opened, clicked, bounced, replied counts\n     * Calculate rates: openRate, clickRate, replyRate\n6. Reply detection:\n   - Monitor replies via Mailgun inbound routes or forwarding\n   - Parse reply content for booking intent\n7. Webhook endpoint:\n   - Express/serverless function to receive Mailgun webhooks\n   - Signature verification for security",
        "testStrategy": "Unit tests with sample webhook payloads. Test each event type handled correctly. Test status updates triggered. Test bounce handling marks lead invalid.",
        "priority": "high",
        "dependencies": [
          "8",
          "11",
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DeliveryTracker Class with Dependencies",
            "description": "Implement the DeliveryTracker class constructor that receives MailgunClient, LeadRepository, and StatusTracker instances.",
            "dependencies": [],
            "details": "Define the class in src/email-automation/delivery-tracker.ts with private readonly properties for the three dependencies. Add TypeScript interfaces for the dependencies if not already defined. Ensure proper dependency injection pattern.",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization with mock dependencies. Verify properties are set correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Webhook Processing Method",
            "description": "Create processWebhook(payload: unknown): Promise<void> method to parse, validate, and route events using MailgunClient.parseWebhook().",
            "dependencies": [
              1
            ],
            "details": "Use MailgunClient.parseWebhook() to parse payload. Add switch or if-else routing based on event.type to specific handlers. Include error handling for invalid payloads and log webhook events.",
            "status": "pending",
            "testStrategy": "Unit tests with sample Mailgun webhook payloads for each event type. Verify correct handler routing and validation errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop Event Handlers for All Email Events",
            "description": "Implement handleDelivered, handleOpened, handleClicked, handleBounced, and handleReplied methods with specific lead status updates.",
            "dependencies": [
              1,
              2
            ],
            "details": "For handleBounced: check if hard bounce and mark lead as 'invalid_email'. For handleReplied: update lead status to 'responded' and halt follow-up sequence using StatusTracker. Save all events to email_events table linking to lead and campaign.",
            "status": "pending",
            "testStrategy": "Unit tests for each handler with mock events. Test bounce type detection, status updates, sequence halting, and event storage.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Email Metrics Aggregation Method",
            "description": "Implement getEmailMetrics(campaignId: string): Promise<EmailMetrics> to calculate counts and rates for sent, delivered, opened, clicked, bounced, replied.",
            "dependencies": [
              1
            ],
            "details": "Query email_events table by campaignId. Compute rates: openRate = opened/delivered, clickRate = clicked/opened, replyRate = replied/delivered. Return structured EmailMetrics interface with counts and rates.",
            "status": "pending",
            "testStrategy": "Unit tests with mock database data for different campaign scenarios. Verify count accuracy and rate calculations (handle division by zero).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Secure Webhook Endpoint Handler",
            "description": "Build Express/serverless function endpoint to receive Mailgun webhooks with signature verification.",
            "dependencies": [
              2
            ],
            "details": "Create POST /webhooks/mailgun endpoint. Verify Mailgun signature using MailgunClient. Call deliveryTracker.processWebhook(req.body). Return 200 on success, 400/401 on validation failure. Add reply detection parsing if inbound route.",
            "status": "pending",
            "testStrategy": "Integration tests with real Mailgun webhook signatures. Test valid/invalid signatures, event processing, and HTTP responses.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Specify webhook signature verification, event routing patterns, and reply intent detection.",
        "updatedAt": "2026-01-31T13:17:17.596Z"
      },
      {
        "id": "27",
        "title": "Integrate Google Calendar for Meeting Booking",
        "description": "Build meeting scheduling flow with availability checking and event creation.",
        "details": "Create src/email-automation/calendar-integration.ts:\n1. CalendarIntegration class:\n   - Constructor receives CalendarClient, LeadRepository\n2. Availability:\n   - getAvailability(days: number): Promise<TimeSlot[]>\n     * Query next N days from primary calendar\n     * Return available 15/30-minute slots\n     * Respect business hours (9am-5pm)\n3. Booking link generation:\n   - generateBookingLink(leadId: string, slots: TimeSlot[]): string\n     * Create signed URL with lead ID and slot options\n     * URL points to booking endpoint\n   - Alternatively: Generate Calendly-style link with availability\n4. Booking execution:\n   - bookMeeting(leadId: string, slot: TimeSlot): Promise<CalendarEvent>\n     * Verify slot still available\n     * Create event with lead as attendee\n     * Include audit summary in event description\n     * Update lead status to 'booked'\n5. Confirmation:\n   - sendBookingConfirmation(leadId: string, event: CalendarEvent): Promise<void>\n     * Send confirmation email to lead\n     * Send notification to sales team\n6. Cancellation:\n   - cancelMeeting(leadId: string, eventId: string): Promise<void>\n     * Delete calendar event\n     * Update lead status back to 'responded'\n     * Optionally: Resume follow-up sequence",
        "testStrategy": "Integration tests with test calendar. Test availability returns correct slots. Test booking creates event with correct details. Test confirmation emails sent.",
        "priority": "medium",
        "dependencies": [
          "9",
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CalendarIntegration Class with Constructor",
            "description": "Implement the CalendarIntegration class constructor that receives CalendarClient and LeadRepository dependencies.",
            "dependencies": [],
            "details": "Define the class in src/email-automation/calendar-integration.ts with private readonly properties for CalendarClient and LeadRepository. Add TypeScript interfaces for dependencies if missing.",
            "status": "pending",
            "testStrategy": "Unit test constructor initialization and dependency injection validation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement getAvailability Method",
            "description": "Build getAvailability(days: number) to query primary calendar for next N days and return 15/30-minute slots within 9am-5pm business hours.",
            "dependencies": [
              1
            ],
            "details": "Use CalendarClient to fetch events, calculate free slots respecting business hours (9:00-17:00), filter 15/30-min increments, return TimeSlot[] with start/end times.",
            "status": "pending",
            "testStrategy": "Integration test with mock calendar events verifying correct slot generation and business hour filtering.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop generateBookingLink Method",
            "description": "Create generateBookingLink(leadId: string, slots: TimeSlot[]) to generate signed URL pointing to booking endpoint with lead ID and slot options.",
            "dependencies": [
              1
            ],
            "details": "Implement signed URL creation using leadId and serialized slots, ensure URL security and expiration, alternative Calendly-style link if specified.",
            "status": "pending",
            "testStrategy": "Unit test URL generation format, signature validation, and slot deserialization on receiving end.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement bookMeeting and cancelMeeting Methods",
            "description": "Build bookMeeting(leadId: string, slot: TimeSlot) for event creation and verification; add cancelMeeting(leadId: string, eventId: string) for deletion and lead status update.",
            "dependencies": [
              1,
              2
            ],
            "details": "In bookMeeting: verify slot availability, create event with lead attendee, add audit summary, update lead to 'booked'. In cancelMeeting: delete event, revert lead to 'responded'.",
            "status": "pending",
            "testStrategy": "Integration tests confirming event creation/deletion, lead status updates, and slot verification logic.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add sendBookingConfirmation Method",
            "description": "Implement sendBookingConfirmation(leadId: string, event: CalendarEvent) to send emails to lead and sales team.",
            "dependencies": [
              1,
              4
            ],
            "details": "Fetch lead details, compose confirmation email with event details, send to lead email, notify sales team via separate channel or email list.",
            "status": "pending",
            "testStrategy": "Mock email service tests verifying correct recipients, email content with event details, and dual notification delivery.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement availability slot generation algorithm, double-booking prevention, and timezone conversion.",
        "updatedAt": "2026-01-31T15:26:36.888Z"
      },
      {
        "id": "28",
        "title": "Setup React Dashboard Project",
        "description": "Initialize React frontend with TypeScript, Vite, Tailwind CSS, and core dependencies.",
        "details": "Create src/dashboard/ React application:\n1. Project initialization:\n   - Create with Vite: npm create vite@latest dashboard -- --template react-ts\n   - Configure TypeScript with strict mode\n   - Install and configure Tailwind CSS 3\n2. Core dependencies:\n   - @tanstack/react-query for server state\n   - react-router-dom for routing\n   - @supabase/supabase-js for auth and data\n   - recharts for data visualization\n   - @headlessui/react for accessible UI components\n3. Project structure:\n   - src/components/ - Reusable UI components\n   - src/pages/ - Route pages\n   - src/hooks/ - Custom hooks (useLead, useAudit, useCampaign)\n   - src/contexts/ - React contexts (AuthContext, ConfigContext)\n   - src/api/ - API client functions\n   - src/types/ - Import shared types\n4. Routing setup:\n   - / - Dashboard overview\n   - /leads - Lead management\n   - /audits - Audit viewer\n   - /campaigns - Campaign management\n   - /settings - Configuration\n5. Environment variables:\n   - VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY\n6. Development server with hot reload",
        "testStrategy": "Development server runs without errors. Test routes navigate correctly. Verify Tailwind styles apply. Test React Query devtools accessible.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Vite React TypeScript Project",
            "description": "Create the React dashboard project using Vite with TypeScript template and configure strict TypeScript mode.",
            "dependencies": [],
            "details": "Run `npm create vite@latest src/dashboard -- --template react-ts`, navigate to src/dashboard, run `npm install`, update tsconfig.json to enable strict: true, strictNullChecks: true, noImplicitAny: true, and verify with `npm run build`.",
            "status": "pending",
            "testStrategy": "Verify project compiles without errors using `npm run dev` and `npm run build`.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install and Configure Tailwind CSS",
            "description": "Install Tailwind CSS v3 and configure it properly in the Vite React project.",
            "dependencies": [
              1
            ],
            "details": "Run `npm install -D tailwindcss postcss autoprefixer`, initialize with `npx tailwindcss init -p`, update tailwind.config.js to include content paths for src/**/*.{ts,tsx}, add Tailwind directives to src/index.css, and test with sample classes.",
            "status": "pending",
            "testStrategy": "Apply Tailwind classes to App.tsx and verify styles render correctly in development server.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Install Core Dependencies and Setup Environment",
            "description": "Install required dependencies and configure Supabase environment variables.",
            "dependencies": [
              2
            ],
            "details": "Install `@tanstack/react-query react-router-dom @supabase/supabase-js recharts @headlessui/react` via npm, create .env file with VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY placeholders, update vite.config.ts for env prefix if needed.",
            "status": "pending",
            "testStrategy": "Run `npm run dev` without errors, verify imports work in App.tsx, check env vars accessible via import.meta.env.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Project Directory Structure and Basic Files",
            "description": "Set up the specified folder structure and create essential directories and type imports.",
            "dependencies": [
              3
            ],
            "details": "Create directories: src/components/, src/pages/, src/hooks/, src/contexts/, src/api/, src/types/. Add index.ts exports in each, create placeholder files like AuthContext.tsx, api/index.ts, types/index.ts importing shared types from monorepo.",
            "status": "pending",
            "testStrategy": "Verify folder structure exists, no import errors when adding basic exports, tsc compiles successfully.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Routing and Launch Development Server",
            "description": "Setup React Router with specified routes and verify hot reload functionality.",
            "dependencies": [
              4
            ],
            "details": "Wrap App.tsx with BrowserRouter, create routes for '/', '/leads', '/audits', '/campaigns', '/settings' with placeholder pages, implement basic navigation layout, run `npm run dev` with hot reload working.",
            "status": "pending",
            "testStrategy": "Navigate between all 5 routes successfully, verify hot reload updates without full refresh, Tailwind styles apply to navigation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail Vite configuration options, Tailwind theme customization, and React Query provider setup.",
        "updatedAt": "2026-01-31T12:59:44.927Z"
      },
      {
        "id": "29",
        "title": "Build Lead Management Interface",
        "description": "Create React components for lead listing, filtering, search, and bulk actions.",
        "details": "Create src/dashboard/components/LeadManagement.tsx:\n1. LeadTable component:\n   - Display leads in sortable, filterable table\n   - Columns: business_name, category, rating, status, qualification_score, last_contacted\n   - Row click expands to show preview\n   - Checkbox selection for bulk actions\n2. LeadFilters component:\n   - Status dropdown (pending, contacted, responded, booked, disqualified)\n   - Category multi-select\n   - Rating range slider\n   - Date range picker\n   - Search input for business name\n3. LeadCard component:\n   - Preview card with key metrics\n   - Website thumbnail (if available)\n   - Quick action buttons (audit, email, archive)\n4. BulkActions component:\n   - Select all / deselect all\n   - Bulk status change\n   - Bulk add to campaign\n   - Bulk delete\n5. Pagination:\n   - Infinite scroll or numbered pagination\n   - Items per page selector\n6. Data fetching:\n   - useLeads() hook with React Query\n   - Optimistic updates for status changes\n7. Empty states:\n   - No leads found message\n   - Call to action to run discovery",
        "testStrategy": "E2E tests with Playwright. Test filter combinations work. Test sorting changes order. Test bulk select/actions. Test pagination loads more. Test search filters results.",
        "priority": "medium",
        "dependencies": [
          "11",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LeadTable component with core table functionality",
            "description": "Implement the LeadTable component displaying leads in a sortable, filterable table with specified columns and checkbox selection for bulk actions.",
            "dependencies": [],
            "details": "Create LeadTable.tsx with columns for business_name, category, rating, status, qualification_score, last_contacted. Add sorting headers, checkbox column for selection, and row click handler stub for expand preview. Use React Table or similar for table functionality.",
            "status": "pending",
            "testStrategy": "Unit test column rendering, sorting functionality, checkbox selection state, and row click events.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement LeadFilters component with all filter controls",
            "description": "Build LeadFilters component including status dropdown, category multi-select, rating slider, date range picker, and business name search input.",
            "dependencies": [],
            "details": "Create LeadFilters.tsx with controlled form inputs: Select for status (pending/contacted/responded/booked/disqualified), MultiSelect for categories, RangeSlider for rating (0-5), DateRangePicker, and TextInput for search. Implement onFilterChange callback.",
            "status": "pending",
            "testStrategy": "Test each filter control renders correctly, emits filter changes on interaction, and maintains local state.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop LeadCard preview component and row expansion",
            "description": "Create LeadCard component for expanded row preview and integrate expandable rows in LeadTable.",
            "dependencies": [
              1
            ],
            "details": "Build LeadCard.tsx showing key metrics, website thumbnail (if available), and quick action buttons (audit/email/archive). Modify LeadTable to support row expansion on click with LeadCard in expanded row.",
            "status": "pending",
            "testStrategy": "Test LeadCard renders lead data correctly, buttons emit actions, and table expansion toggles properly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build BulkActions component and integrate selection",
            "description": "Implement BulkActions toolbar with select all/deselect, bulk status change, add to campaign, and delete functionality.",
            "dependencies": [
              1
            ],
            "details": "Create BulkActions.tsx with buttons for Select All/Deselect All, Status dropdown for bulk change, Campaign selector, and Delete confirmation. Connect to LeadTable selection state and implement bulk action handlers.",
            "status": "pending",
            "testStrategy": "Test bulk selection works, actions dispatch correct API calls, and optimistic updates apply.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add data fetching, pagination, and empty states",
            "description": "Integrate useLeads() hook with React Query, implement pagination, and add empty state handling.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create useLeads hook with React Query for data fetching, filtering, sorting, and pagination (infinite scroll preferred). Add EmptyState component for no leads with CTA. Implement optimistic updates for status changes.",
            "status": "pending",
            "testStrategy": "E2E tests: filter combinations, sorting order changes, bulk actions, pagination loading, search filtering, empty states.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement table virtualization, filter state synchronization, and bulk action confirmation flows.",
        "updatedAt": "2026-01-31T15:33:59.970Z"
      },
      {
        "id": "30",
        "title": "Create Audit Results Viewer",
        "description": "Build components to display technical audit findings with charts and evidence gallery.",
        "details": "Create src/dashboard/components/AuditViewer.tsx:\n1. AuditReport component:\n   - Header with business name, URL, audit date\n   - Score summary cards (performance, accessibility, responsiveness)\n   - Detailed findings sections\n2. PerformanceSection:\n   - Core Web Vitals chart (FCP, LCP, CLS as gauges)\n   - Load time timeline visualization\n   - Code coverage pie chart (used vs unused)\n   - Recommendations list\n3. AccessibilitySection:\n   - Violations list grouped by severity\n   - WCAG criterion references\n   - Affected element highlighting\n   - Legal risk warning banner for critical issues\n4. EvidenceGallery component:\n   - Screenshot thumbnails grid\n   - Click to open full-size modal\n   - Video player for load recordings\n   - Download buttons\n5. ResponsivenessSection:\n   - Device comparison screenshots (mobile/tablet/desktop)\n   - Issue list with affected viewports\n6. PDF Export:\n   - Generate downloadable PDF report\n   - Include all metrics and screenshots\n   - Branded template\n7. Compare mode:\n   - Select two audits to compare side-by-side\n   - Highlight improvements/regressions",
        "testStrategy": "E2E tests verify report renders with all sections. Test screenshot gallery zoom works. Test video playback. Test PDF download produces valid file.",
        "priority": "medium",
        "dependencies": [
          "23",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AuditReport Header and Summary Cards",
            "description": "Build the main AuditReport component with header displaying business name, URL, audit date, and score summary cards for performance, accessibility, and responsiveness metrics.",
            "dependencies": [],
            "details": "Use Tailwind CSS for responsive cards with color-coded scores (green/yellow/red). Fetch audit data via props. Include drill-down links to detailed sections. Ensure mobile-friendly layout.",
            "status": "pending",
            "testStrategy": "Unit test renders correct header data. Snapshot test for score cards. Test responsive breakpoints.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement PerformanceSection with Charts",
            "description": "Develop PerformanceSection component featuring Core Web Vitals gauges (FCP, LCP, CLS), load time timeline, code coverage pie chart, and recommendations list.",
            "dependencies": [
              1
            ],
            "details": "Use Recharts for gauges, timeline (line chart), and pie chart. Map CWV metrics to gauge values (0-100). Display recommendations as prioritized bullet list with action items.",
            "status": "pending",
            "testStrategy": "Unit tests verify chart data binding. Test gauge color thresholds. Mock data renders correct visualizations.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build AccessibilitySection and EvidenceGallery",
            "description": "Create AccessibilitySection with violations grouped by severity, WCAG references, highlighting, and legal risk banner. Implement EvidenceGallery for screenshots/videos with modal and downloads.",
            "dependencies": [
              1
            ],
            "details": "Group violations: critical/high/medium/low. Use React Modal for full-size view. Integrate EvidenceStore for signed URLs. Add video player with controls and download buttons per asset.",
            "status": "pending",
            "testStrategy": "Test violation grouping logic. E2E test gallery modal opens/closes. Verify video playback and download triggers.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop ResponsivenessSection and PDF Export",
            "description": "Implement ResponsivenessSection showing device comparison screenshots and viewport issues. Add PDF export functionality generating branded report with all metrics and screenshots.",
            "dependencies": [
              2,
              3
            ],
            "details": "Display 3-column grid: mobile/tablet/desktop screenshots from EvidenceStore. Use jsPDF or html2canvas for export. Include all sections in PDF with branded header/footer.",
            "status": "pending",
            "testStrategy": "Test screenshot grid renders correctly. Verify PDF generates with all content. Test download produces valid file.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Compare Mode and Final Integration",
            "description": "Implement side-by-side compare mode for two audits highlighting improvements/regressions. Integrate all components into AuditViewer.tsx with routing and state management.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use React state or Context for audit selection. Side-by-side layout with delta indicators (+/- scores). Color-code improvements (green) vs regressions (red). Add export for comparisons.",
            "status": "pending",
            "testStrategy": "E2E tests verify compare mode switches audits. Test delta calculations accurate. Full component integration test renders complete viewer.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Specify chart configurations, modal state management, PDF generation layout, and compare delta calculations.",
        "updatedAt": "2026-02-02T00:28:49.206Z"
      },
      {
        "id": "31",
        "title": "Implement Campaign Dashboard",
        "description": "Build real-time campaign monitoring interface with performance metrics and funnel visualization.",
        "details": "Create src/dashboard/components/CampaignDashboard.tsx:\n1. CampaignList component:\n   - Active campaigns with status indicators\n   - Quick stats: sent, opened, replied\n   - Play/pause buttons\n2. CampaignDetail component:\n   - Campaign name, dates, template preview\n   - Lead count and progress\n   - Sequence visualization (step 1  step 2  step 3)\n3. MetricsPanel component:\n   - Real-time counters: sent, delivered, opened, clicked, replied\n   - Rate calculations with tooltips\n   - Comparison to benchmarks\n4. FunnelChart component:\n   - Visual funnel: Sent  Delivered  Opened  Clicked  Replied  Booked\n   - Drop-off percentages at each stage\n   - Click to see leads at each stage\n5. TimelineChart component:\n   - Line chart showing daily sends and responses\n   - Toggle between metrics\n   - Date range selector\n6. TopPerformers component:\n   - Leads with highest engagement\n   - Best performing templates\n7. Real-time updates:\n   - Poll or WebSocket for live metrics\n   - Animated counter transitions\n8. Actions:\n   - Create new campaign wizard\n   - Edit campaign settings\n   - Export campaign data",
        "testStrategy": "E2E tests verify dashboard loads with data. Test funnel chart renders correctly. Test real-time updates reflect new events. Test campaign actions work.",
        "priority": "medium",
        "dependencies": [
          "14",
          "26",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CampaignList and CampaignDetail Components",
            "description": "Implement the CampaignList showing active campaigns with status indicators, quick stats (sent, opened, replied), and play/pause buttons, plus CampaignDetail with name, dates, template preview, lead count, progress, and sequence visualization.",
            "dependencies": [],
            "details": "Create src/dashboard/components/CampaignList.tsx and CampaignDetail.tsx. Use Tailwind CSS for styling. Fetch campaign data from AnalyticsService (Task 14). Implement status indicators as colored badges and sequence as horizontal steppers with arrows.",
            "status": "pending",
            "testStrategy": "Unit tests verify component renders with mock data. Test status indicators show correct colors. Test play/pause buttons dispatch correct actions. Snapshot tests for visual layout.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement MetricsPanel and TopPerformers Components",
            "description": "Build MetricsPanel with real-time counters for sent, delivered, opened, clicked, replied, rate calculations with tooltips, benchmark comparisons, and TopPerformers showing highest engagement leads and best templates.",
            "dependencies": [
              1
            ],
            "details": "Create src/dashboard/components/MetricsPanel.tsx and TopPerformers.tsx. Use react-countup for animated counters. Fetch metrics from getCampaignPerformance API. Implement tooltips with react-tooltip showing formulas like open rate = opened/sent * 100%.",
            "status": "pending",
            "testStrategy": "Integration tests verify metrics display correct calculations. Test tooltips show on hover. Test TopPerformers lists top 5 items correctly. Test empty states render properly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop FunnelChart and TimelineChart Components",
            "description": "Create FunnelChart visualizing Sent  Delivered  Opened  Clicked  Replied  Booked with drop-off percentages and lead drill-down, plus TimelineChart with daily sends/responses line chart, metric toggles, and date range selector.",
            "dependencies": [
              1
            ],
            "details": "Use Recharts library for both charts. Create src/dashboard/components/FunnelChart.tsx with trapezoid shapes and click handlers to filter leads. TimelineChart.tsx with LineChart, toggle buttons for metrics, and react-datepicker for range selection. Call getConversionFunnel API.",
            "status": "pending",
            "testStrategy": "Unit tests verify funnel percentages calculate correctly (e.g., drop-off = (prev - current)/prev * 100). Test TimelineChart renders multiple lines. Test date range filtering. E2E test click interactions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Real-time Updates and Assemble Main Dashboard",
            "description": "Add polling/WebSocket for live metrics updates with animated transitions, assemble all components into CampaignDashboard.tsx layout, and implement responsive grid layout.",
            "dependencies": [
              2,
              3
            ],
            "details": "Use SWR or React Query for data fetching with 5s polling interval. Implement framer-motion for counter animations. Create main CampaignDashboard.tsx with resizable grid using react-grid-layout. Ensure mobile responsiveness with Tailwind breakpoints.",
            "status": "pending",
            "testStrategy": "Integration tests verify real-time updates reflect mock API changes. Test animations complete smoothly. Test responsive layout on mobile/desktop. Performance test load time under 2s.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Campaign Actions and Final Testing",
            "description": "Implement create new campaign wizard, edit settings modals, export data functionality, and comprehensive E2E testing for the complete dashboard.",
            "dependencies": [
              4
            ],
            "details": "Use react-hook-form for wizard forms linking to CampaignManager (Task 25). Add export to CSV with PapaParse library. Implement modals with Headless UI. Connect actions to existing campaign APIs. Add loading states and error boundaries.",
            "status": "pending",
            "testStrategy": "E2E tests using Playwright: verify dashboard loads with data, funnel chart renders correctly, real-time updates reflect events, campaign actions (create/edit/export) work end-to-end, protected routes require auth (Task 33).",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail real-time data synchronization, funnel visualization math, and responsive grid layouts.",
        "updatedAt": "2026-02-02T00:56:07.932Z"
      },
      {
        "id": "32",
        "title": "Build Settings and Configuration Interface",
        "description": "Create settings page for email templates, search criteria, and integration management.",
        "details": "Create src/dashboard/components/Settings.tsx:\n1. TemplateEditor component:\n   - List of saved templates\n   - Rich text editor for template content\n   - Variable picker ({{business_name}}, {{evidence_link}}, etc.)\n   - Preview with sample data\n   - Validation errors display\n2. SearchCriteriaConfig component:\n   - Default location/radius settings\n   - Category presets (restaurants, dentists, etc.)\n   - Qualification thresholds (min rating, min score)\n   - Save/load search presets\n3. IntegrationSettings component:\n   - Mailgun connection status and test button\n   - Google Calendar connection with OAuth flow\n   - Supabase connection verification\n   - API key management (masked display)\n4. NotificationSettings:\n   - Email notifications for booked meetings\n   - Slack webhook integration (optional)\n   - Daily digest preferences\n5. BrandingSettings:\n   - Company logo upload\n   - Email signature customization\n   - Color theme preferences\n6. DataManagement:\n   - Export all leads as CSV\n   - Import leads from CSV\n   - Data retention settings",
        "testStrategy": "E2E tests for template save/load. Test variable picker inserts correctly. Test API connection tests return results. Test CSV export produces valid file.",
        "priority": "low",
        "dependencies": [
          "24",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TemplateEditor Component",
            "description": "Build the email template editor with list of saved templates, rich text editor, variable picker, preview, and validation.",
            "dependencies": [],
            "details": "Implement in src/dashboard/components/TemplateEditor.tsx using React Quill for rich text, dropdown for variables like {{business_name}}, sample data preview pane, and form validation with react-hook-form.",
            "status": "done",
            "testStrategy": "Unit tests for variable insertion, E2E tests for save/load templates and preview rendering with sample data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:58:08.773Z"
          },
          {
            "id": 2,
            "title": "Create SearchCriteriaConfig Component",
            "description": "Develop search criteria configuration with location/radius, category presets, thresholds, and preset save/load.",
            "dependencies": [],
            "details": "Create src/dashboard/components/SearchCriteriaConfig.tsx with Google Maps autocomplete for location, multi-select for categories (restaurants, dentists), sliders for thresholds, and CRUD for presets using localStorage or API.",
            "status": "done",
            "testStrategy": "Test preset save/load, threshold validation, category filtering, and location input integration.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:58:08.777Z"
          },
          {
            "id": 3,
            "title": "Create IntegrationSettings Component",
            "description": "Build integration management for Mailgun, Google Calendar OAuth, Supabase verification, and masked API keys.",
            "dependencies": [],
            "details": "Implement src/dashboard/components/IntegrationSettings.tsx with connection status indicators, test buttons calling APIs, OAuth flow for Google Calendar, and secure input for API keys with masking.",
            "status": "done",
            "testStrategy": "Integration tests for connection test buttons, mock OAuth flow, and API key validation/masking.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:58:08.780Z"
          },
          {
            "id": 4,
            "title": "Implement Notification and Branding Settings",
            "description": "Create components for email/Slack notifications, daily digest, logo upload, signature, and color themes.",
            "dependencies": [],
            "details": "Build src/dashboard/components/NotificationSettings.tsx and BrandingSettings.tsx with toggles for notifications, webhook input, file upload for logo with preview, textarea for signature, and color picker.",
            "status": "done",
            "testStrategy": "Test notification toggles persist, logo upload processes images, color theme applies to preview.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:58:08.783Z"
          },
          {
            "id": 5,
            "title": "Build DataManagement and Main Settings Page",
            "description": "Implement CSV export/import, data retention, and assemble all components into Settings.tsx page.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create src/dashboard/components/DataManagement.tsx for CSV operations using PapaParse, retention sliders. Then create src/dashboard/components/Settings.tsx as tabbed interface (Template, Search, Integration, etc.) with React Tabs.",
            "status": "done",
            "testStrategy": "E2E tests for CSV export/import validity, data retention settings save, full settings page navigation and form persistence.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:58:08.791Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Implement rich text editor integrations, file upload validation, and tab state persistence.",
        "updatedAt": "2026-02-03T13:58:08.791Z"
      },
      {
        "id": "33",
        "title": "Implement Supabase Authentication",
        "description": "Add user authentication with email/password login, session management, and protected routes.",
        "details": "Implement authentication in dashboard:\n1. AuthContext:\n   - Store user session state\n   - Provide login, logout, signup functions\n   - Auto-refresh session tokens\n2. Supabase Auth integration:\n   - signInWithPassword(email, password)\n   - signUp(email, password)\n   - signOut()\n   - onAuthStateChange listener\n3. LoginPage component:\n   - Email/password form\n   - Error message display\n   - Remember me checkbox\n   - Forgot password link\n4. SignupPage component:\n   - Registration form with validation\n   - Email verification flow\n   - Terms acceptance checkbox\n5. ProtectedRoute component:\n   - Wrap routes requiring auth\n   - Redirect to login if not authenticated\n   - Show loading state while checking auth\n6. User profile:\n   - Display user email in header\n   - Logout button\n   - Password change form\n7. Row Level Security:\n   - Configure Supabase RLS policies\n   - Users only see their own data\n8. Session management:\n   - Auto-logout on inactivity\n   - Secure cookie storage",
        "testStrategy": "E2E tests for login flow. Test protected routes redirect. Test logout clears session. Test invalid credentials show error. Test signup creates user.",
        "priority": "medium",
        "dependencies": [
          "7",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AuthContext with session management",
            "description": "Implement React Context for storing user session state, providing login/logout/signup functions, and auto-refreshing session tokens using Supabase auth listeners.",
            "dependencies": [],
            "details": "Use createContext and useEffect to initialize Supabase client, implement onAuthStateChange listener for real-time session updates, add token refresh logic, and expose auth methods to child components.",
            "status": "pending",
            "testStrategy": "Unit test session state updates, mock onAuthStateChange events, verify login/logout functions update context correctly, test token refresh on expiry.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build LoginPage and SignupPage components",
            "description": "Create responsive login and signup forms with email/password inputs, validation, error handling, remember me checkbox, forgot password link, and terms acceptance.",
            "dependencies": [
              1
            ],
            "details": "Use shadcn/ui form components with Zod validation, integrate AuthContext methods for signInWithPassword and signUp, handle Supabase error responses, implement loading states and success redirects.",
            "status": "pending",
            "testStrategy": "Component tests for form validation, E2E tests for successful/failed login/signup flows, test error message display for invalid credentials, verify redirects after auth.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement ProtectedRoute component",
            "description": "Create HOC or wrapper component to protect routes requiring authentication, redirect unauthenticated users to login, and show loading spinner during auth checks.",
            "dependencies": [
              1
            ],
            "details": "Use AuthContext to check session state, implement useEffect for auth status polling, render children only when authenticated, handle loading/unauthenticated states with Next.js router redirects.",
            "status": "pending",
            "testStrategy": "E2E tests verify redirect to login when unauthenticated, test loading state displays briefly, test authenticated access to protected routes, test session expiry handling.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add User Profile and session features",
            "description": "Integrate user email display in header, logout button, password change form, auto-logout on inactivity, and secure session cookie storage.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create UserProfile component using supabase.auth.updateUser for password changes, implement idle timeout with localStorage for activity tracking, configure secure httpOnly cookies for session persistence.",
            "status": "pending",
            "testStrategy": "Test password change flow requires auth, verify auto-logout after inactivity, test logout clears cookies and redirects, test profile displays correct user data.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure Supabase RLS policies and test auth flow",
            "description": "Set up Row Level Security policies in Supabase dashboard for user data isolation, configure auth settings (redirect URLs, email confirmation), and run complete E2E tests.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create RLS policies ensuring users only access their own records (using auth.uid()), add site URL to allowed redirects, optionally disable email confirmation for dev, test full auth lifecycle.",
            "status": "pending",
            "testStrategy": "E2E tests: complete login/signup/logout cycles, verify RLS prevents data access across users, test protected routes, invalid credentials errors, session persistence across refreshes.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail session persistence strategies, RLS policy definitions, and protected route patterns.",
        "updatedAt": "2026-02-02T00:31:38.935Z"
      },
      {
        "id": "34",
        "title": "End-to-End Workflow Testing",
        "description": "Create comprehensive E2E tests covering complete user journeys from discovery to booked meetings.",
        "details": "Create tests/e2e/ with Playwright:\n1. Discovery to Audit journey:\n   - User logs in\n   - Configures search criteria\n   - Initiates lead discovery\n   - Views discovered leads\n   - Selects leads for audit\n   - Reviews audit results with evidence\n2. Audit to Campaign journey:\n   - User selects audited leads\n   - Creates email campaign\n   - Configures template with audit variables\n   - Launches campaign\n   - Views delivery metrics\n3. Campaign to Booking journey:\n   - Simulate email open/click events\n   - User views engagement in dashboard\n   - Lead 'replies' (simulate webhook)\n   - User sees status change to 'responded'\n   - Lead books meeting via calendar link\n   - User sees 'booked' status\n4. Error scenarios:\n   - Network failure during discovery\n   - Blocked website during audit\n   - Mailgun rate limit during campaign\n5. Test data:\n   - Seed database with test leads\n   - Mock external services where needed\n   - Clean up after each test\n6. Visual regression:\n   - Screenshot comparisons for dashboard\n   - Fail on unexpected visual changes",
        "testStrategy": "Playwright test suite with full journey coverage. CI/CD runs on every PR. Visual regression with Percy or Chromatic. Test isolation via database transactions.",
        "priority": "high",
        "dependencies": [
          "18",
          "23",
          "25",
          "27",
          "29",
          "30",
          "31"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Discovery to Audit E2E Test",
            "description": "Create Playwright test for complete journey from user login through lead discovery, selection, and audit review with evidence.",
            "dependencies": [],
            "details": "Use Playwright test in tests/e2e/discovery-audit.spec.ts. Implement login, search criteria config, lead discovery initiation, lead selection, audit start, and assert audit results display with evidence screenshots. Use auto-waits and expect assertions.",
            "status": "pending",
            "testStrategy": "Run test locally and in headed mode first. Verify all page interactions complete successfully. Check audit evidence gallery renders.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Audit to Campaign E2E Test",
            "description": "Build Playwright test covering audited lead selection, email campaign creation, template configuration with variables, launch, and metrics verification.",
            "dependencies": [
              1
            ],
            "details": "Create tests/e2e/audit-campaign.spec.ts. Select audited leads, create campaign, configure template using {{business_name}} and {{evidence_link}} variables, launch campaign, navigate to metrics dashboard, assert delivery stats visible.",
            "status": "pending",
            "testStrategy": "Validate template variable substitution in preview. Confirm campaign launch API call succeeds. Assert metrics dashboard updates within timeout.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Campaign to Booking E2E Test",
            "description": "Develop test simulating email engagement, webhook replies, status changes to responded/booked, including calendar booking flow.",
            "dependencies": [
              2
            ],
            "details": "Write tests/e2e/campaign-booking.spec.ts. Mock email open/click events via API, simulate webhook for reply, verify dashboard status updates to 'responded', simulate calendar booking, assert 'booked' status appears.",
            "status": "pending",
            "testStrategy": "Test webhook simulation reliability. Verify status transitions in real-time dashboard. Confirm booking confirmation renders correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Error Scenarios and Test Data Setup",
            "description": "Implement error handling tests for network failures, blocked audits, rate limits, plus database seeding, mocking, and cleanup.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create tests/e2e/error-scenarios.spec.ts. Mock network failures during discovery, blocked sites in audit, Mailgun rate limits. Add test.setup.ts for DB seeding test leads, mock external APIs (Mailgun, webhooks), use transactions for isolation and cleanup.",
            "status": "pending",
            "testStrategy": "Ensure mocks trigger correct error states and UI messages. Verify test data isolation prevents cross-test pollution. Confirm cleanup leaves DB clean.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Setup Visual Regression and CI Integration",
            "description": "Configure visual regression testing with screenshots and integrate full suite into CI/CD pipeline with Percy/Chromatic.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add playwright.config.ts with screenshotOnFailure, video recording, Percy/Chromatic integration. Create baseline screenshots for dashboard pages. Configure CI (GitHub Actions/Vercel) to run npx playwright test on every PR with parallel workers.",
            "status": "pending",
            "testStrategy": "Run visual tests on multiple viewports/browsers. Verify CI reports pass/fail accurately. Test retry logic for flaky network-dependent tests.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Create test data factories, mock external service scenarios, and visual regression baseline setup.",
        "updatedAt": "2026-02-02T14:34:54.933Z"
      },
      {
        "id": "35",
        "title": "Performance Optimization and Load Testing",
        "description": "Optimize system performance to meet throughput targets and conduct load testing.",
        "details": "Optimize for 100 sites/hour audit throughput:\n1. Parallel audit processing:\n   - Use BrowserContexts for isolation (not new browser instances)\n   - Configure concurrency limit (default: 5)\n   - Load balance across contexts\n2. Lighthouse optimization:\n   - Disable unnecessary audits (PWA, SEO)\n   - Reduce trace recording overhead\n   - Cache DNS lookups\n3. Database optimization:\n   - Add missing indexes identified via EXPLAIN ANALYZE\n   - Optimize frequently-run queries\n   - Implement query result caching\n4. Frontend optimization:\n   - Code splitting for dashboard routes\n   - Lazy load heavy components (charts, PDF generator)\n   - Image optimization for evidence thumbnails\n5. Load testing with k6:\n   - Script simulating 100 concurrent users\n   - Test discovery, audit, and dashboard endpoints\n   - Measure response times (target: p95 < 2s for dashboard)\n   - Identify bottlenecks\n6. Chrome DevTools profiling:\n   - Profile audit execution time\n   - Identify slowest operations\n7. Metrics:\n   - Dashboard loads < 2s\n   - Audit processes 100 sites/hour\n   - API endpoints p95 < 500ms",
        "testStrategy": "k6 load tests run in CI. Performance budgets enforced. Lighthouse CI for dashboard performance. Alert on regression.",
        "priority": "medium",
        "dependencies": [
          "18",
          "23",
          "25"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Parallel Audit Processing with BrowserContexts",
            "description": "Configure the audit engine to use BrowserContexts for site isolation, set concurrency limit to 5, and implement load balancing across contexts to achieve parallel processing.",
            "dependencies": [],
            "details": "Modify Puppeteer integration in src/audit-engine to create multiple BrowserContexts per browser instance instead of new browsers. Implement a queue system for distributing audit jobs across available contexts with max concurrency of 5. Add health checks and context recycling logic.",
            "status": "pending",
            "testStrategy": "Unit tests for context management and load balancing. Integration test processing 10 concurrent audits without resource exhaustion. Measure throughput improvement.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Optimize Lighthouse Audits and Reduce Overhead",
            "description": "Disable unnecessary Lighthouse audits like PWA and SEO, minimize trace recording, and implement DNS caching to speed up performance analysis.",
            "dependencies": [],
            "details": "Update PerformanceAnalyzer class from Task 19 to accept custom Lighthouse config excluding PWA/SEO categories. Reduce trace categories and duration. Integrate a DNS cache using node-cache or similar for repeated domain lookups during audits.",
            "status": "pending",
            "testStrategy": "Benchmark audit time before/after optimizations on sample sites. Verify only required metrics are collected. Test DNS cache hit rate >80%.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Optimize Database with Indexes and Query Caching",
            "description": "Analyze queries with EXPLAIN ANALYZE, add missing indexes, optimize frequent queries, and implement result caching for audit and dashboard data.",
            "dependencies": [],
            "details": "Run EXPLAIN ANALYZE on top queries from audit/dashboard endpoints. Add composite indexes on lead_id, timestamps, status. Refactor N+1 queries to single joins. Implement Redis/memcached caching for audit results and lead lists with TTL=1h.",
            "status": "pending",
            "testStrategy": "EXPLAIN ANALYZE shows index usage >95%. Cache hit rate monitoring. Query performance tests with pgbench or similar.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Apply Frontend Optimizations for Dashboard",
            "description": "Implement code splitting, lazy loading for charts/PDF generator, and image optimization for evidence thumbnails to achieve dashboard load <2s.",
            "dependencies": [],
            "details": "Use React.lazy() and Suspense for heavy dashboard components. Implement dynamic imports for route-based code splitting. Use sharp or similar for thumbnail optimization with WebP format and responsive sizes. Add IntersectionObserver for lazy image loading.",
            "status": "pending",
            "testStrategy": "Lighthouse CI scores >90 performance. Bundle analyzer shows <500KB initial bundle. p95 dashboard load time <2s.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Conduct Load Testing and Profiling with Metrics Validation",
            "description": "Create k6 scripts for 100 concurrent users, profile with Chrome DevTools, validate all performance metrics meet targets, and document bottlenecks.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Write k6 tests targeting discovery/audit/dashboard endpoints with VU=100, duration=5m. Use Chrome DevTools Performance panel to profile audit execution. Validate metrics: 100 sites/hour, API p95<500ms, dashboard p95<2s. Create performance regression dashboard.",
            "status": "pending",
            "testStrategy": "k6 threshold checks fail if targets missed. DevTools flame charts verify no long main-thread tasks. CI integration with performance budgets.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Profile specific bottlenecks, implement caching layers, and define performance budgets with monitoring.",
        "updatedAt": "2026-02-02T14:46:59.220Z"
      },
      {
        "id": "36",
        "title": "Error Handling and Retry Logic Implementation",
        "description": "Implement robust error handling, automatic retries, and graceful degradation across all modules.",
        "details": "Enhance error handling:\n1. Retry strategies:\n   - Exponential backoff with jitter\n   - Max retry attempts (default: 3)\n   - Retryable error types (network, rate limit, timeout)\n   - Non-retryable errors (validation, auth, 4xx)\n2. Maps scraper resilience:\n   - Detect rate limiting, back off and retry\n   - Handle page load failures\n   - Skip individual businesses on error, continue batch\n3. Audit engine resilience:\n   - Handle blocked/inaccessible sites\n   - Timeout after 60s, return partial results\n   - Flag sites requiring manual review\n4. Email automation resilience:\n   - Queue failed sends for retry\n   - Handle Mailgun 5xx errors\n   - Daily retry of bounced messages\n5. Graceful degradation:\n   - Dashboard works with partial data\n   - Show error states, not crash\n   - Fallback to cached data on API failure\n6. Error reporting:\n   - Structured error logs with context\n   - Error aggregation (count by type)\n   - Alert on error rate spikes\n7. Circuit breaker:\n   - Implement for external service calls\n   - Open circuit after N failures\n   - Half-open for testing recovery",
        "testStrategy": "Chaos testing with simulated failures. Test retry logic with mock failures. Test circuit breaker state transitions. Test graceful degradation in UI.",
        "priority": "medium",
        "dependencies": [
          "4",
          "18",
          "23",
          "25"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Retry Strategy with Exponential Backoff",
            "description": "Create a reusable retry utility that implements exponential backoff with jitter, configurable max attempts (default 3), and classification of retryable vs non-retryable errors.",
            "dependencies": [],
            "details": "Develop a retryDecorator or retryAsync function in src/shared/utils/retry.ts. Support retryable errors: network, rate limit (429), timeout. Non-retryable: validation, auth (401/403), 4xx. Include jitter to avoid thundering herd. Log each retry attempt with context.\n<info added on 2026-02-02T15:26:37.626Z>\nYes.\n\nImplementation completed in packages/shared/src/resilience/retry.ts with the following components: retryAsync function implementing exponential backoff with configurable jitter to prevent thundering herd, classifyError function for categorizing retryable errors (network failures, 429 rate limits, timeouts) versus non-retryable errors (validation, 401/403 auth, other 4xx status codes), calculateDelay function with configurable backoff multiplier for delay computation between retry attempts, makeRetryable wrapper function enabling retry logic on any async function, and withRetry decorator for applying retry behavior to class methods. All utilities exported through packages/shared/src/resilience/index.ts and packages/shared/src/index.ts for consumption across the application. Integrates with existing error classes from Task 4 (AppError, RateLimitError, etc.) for consistent error handling and classification.\n</info added on 2026-02-02T15:26:37.626Z>",
            "status": "done",
            "testStrategy": "Unit tests for backoff calculations, jitter randomization, max attempts enforcement. Mock retryable/non-retryable errors. Integration tests with simulated network delays.",
            "parentId": "undefined",
            "updatedAt": "2026-02-02T15:21:09.531Z"
          },
          {
            "id": 2,
            "title": "Add Maps Scraper Error Resilience and Rate Limit Detection",
            "description": "Enhance maps scraper to detect rate limiting, implement backoff retries, handle page load failures, and skip individual businesses while continuing batch processing.",
            "dependencies": [
              1
            ],
            "details": "In scraper module, wrap API calls and page loads with retry strategy. Detect rate limit via status 429 or specific headers. On page load failure (timeout, blocked), log error, skip business, continue batch. Track skipped count in results.",
            "status": "done",
            "testStrategy": "Mock Puppeteer page failures, rate limit responses. Verify batch continues after individual failures. Test skip count accuracy and partial results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T02:40:30.979Z"
          },
          {
            "id": 3,
            "title": "Implement Audit Engine Resilience with Timeouts and Partial Results",
            "description": "Make audit engine handle blocked sites, enforce 60s timeouts, return partial results, and flag sites needing manual review.",
            "dependencies": [
              1
            ],
            "details": "Wrap audit site checks with 60s timeout per site. On timeout/blocked (no response, access denied), return partial audit data, set flag manualReview: true, score: null. Use structured error logging with site URL context.",
            "status": "done",
            "testStrategy": "Mock slow/blocked sites, verify 60s timeout triggers. Test partial results preserve successful data. Chaos tests with random site failures.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T02:42:16.071Z"
          },
          {
            "id": 4,
            "title": "Build Email Automation Resilience and Queue Management",
            "description": "Add retry queue for failed email sends, handle Mailgun 5xx errors, and implement daily retry for bounced messages.",
            "dependencies": [
              1
            ],
            "details": "Create email retry queue in Supabase (table: failed_emails with retry_count, last_attempt, status). On Mailgun 5xx, queue for retry using exponential backoff. Daily cron job retries bounced/permanent failures up to max attempts.",
            "status": "done",
            "testStrategy": "Mock Mailgun API failures (5xx, bounces). Verify queue insertion, retry logic, daily cron execution. Test max retry exhaustion handling.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T02:44:10.839Z"
          },
          {
            "id": 5,
            "title": "Implement Graceful Degradation, Circuit Breaker, and Error Reporting",
            "description": "Add circuit breaker for external calls, graceful UI degradation with cached data fallbacks, structured logging, error aggregation, and spike alerts.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Circuit breaker in src/shared/circuit-breaker.ts: open after 5 failures, half-open after 30s. Dashboard: show partial data/errors, fallback to cache on API fail. Structured logs with context (Sentry/structured-logger). Aggregate errors by type, alert >5% rate.\n<info added on 2026-02-02T15:26:51.919Z>\nImplemented: 1) Circuit breaker in packages/shared/src/resilience/circuit-breaker.ts with CircuitBreaker class (closed/open/half-open states), CircuitBreakerRegistry for managing multiple breakers. 2) Error reporter in error-reporter.ts with aggregation, fingerprinting, rate alerting. 3) Timeout utilities in timeout.ts with withTimeout, withDeadline, cancellableTimeout. 4) Frontend graceful degradation in apps/dashboard/src/hooks/useResilientQuery.ts (useResilientQuery, useResilientMutation hooks with circuit breaker). 5) ErrorBoundary component in apps/dashboard/src/components/ui/ErrorBoundary.tsx for UI error handling.\n</info added on 2026-02-02T15:26:51.919Z>",
            "status": "done",
            "testStrategy": "Chaos testing: inject failures, verify circuit states transition correctly. UI E2E: test partial data display, cache fallback. Monitor error aggregation accuracy.",
            "parentId": "undefined",
            "updatedAt": "2026-02-02T15:21:09.748Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Define retry classification rules, circuit breaker state transitions, and chaos testing scenarios.",
        "updatedAt": "2026-02-03T02:44:10.839Z"
      },
      {
        "id": "37",
        "title": "Create Documentation and Deployment Guide",
        "description": "Write comprehensive documentation for architecture, API reference, and deployment procedures.",
        "details": "Create docs/ directory:\n1. architecture.md:\n   - System overview diagram\n   - Module responsibilities\n   - Data flow descriptions\n   - Technology choices rationale\n2. api-reference.md:\n   - All public API endpoints\n   - Request/response schemas\n   - Authentication requirements\n   - Example curl commands\n3. deployment.md:\n   - Prerequisites (Node.js, Supabase account, etc.)\n   - Environment variable configuration\n   - Supabase setup instructions\n   - MCP server configuration\n   - Vercel/Railway deployment steps\n   - Domain and SSL setup\n4. development-guide.md:\n   - Local setup instructions\n   - Running tests\n   - Code style guidelines\n   - PR process\n5. user-guide.md:\n   - Dashboard walkthrough\n   - Creating first campaign\n   - Interpreting audit results\n   - Troubleshooting common issues\n6. API key setup:\n   - How to obtain Mailgun API key\n   - Google OAuth setup for Calendar\n   - Supabase project creation",
        "testStrategy": "Documentation review by team member. Test deployment guide on fresh environment. Verify all code examples work.",
        "priority": "low",
        "dependencies": [
          "34"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create docs/ Directory and Architecture Documentation",
            "description": "Initialize the docs/ directory structure and write comprehensive architecture.md covering system overview, modules, data flow, and tech rationale.",
            "dependencies": [],
            "details": "Create docs/ folder with subfolders if needed. In architecture.md: include Mermaid diagram for system overview, list module responsibilities (e.g., audit-engine, lead-discovery), describe data flows between components, justify tech choices like Node.js, Supabase, Puppeteer. Ensure diagram is interactive.",
            "status": "done",
            "testStrategy": "Verify diagram renders correctly in Markdown viewers. Cross-reference with actual codebase modules.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:39:18.691Z"
          },
          {
            "id": 2,
            "title": "Develop API Reference Documentation",
            "description": "Document all public API endpoints in api-reference.md with schemas, auth details, and curl examples.",
            "dependencies": [],
            "details": "List all endpoints from codebase (e.g., /audits, /leads). Include request/response JSON schemas using code blocks. Detail authentication (API keys, JWT). Provide working curl examples for POST/GET operations. Follow OpenAPI best practices for structure.",
            "status": "done",
            "testStrategy": "Test all curl examples execute successfully against staging API. Validate schemas match actual responses.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:39:18.697Z"
          },
          {
            "id": 3,
            "title": "Write Deployment Guide",
            "description": "Create deployment.md with prerequisites, env config, Supabase setup, server config, and Vercel/Railway steps.",
            "dependencies": [],
            "details": "Cover Node.js version, Supabase account creation and bucket setup, all required ENV vars with descriptions, MCP server config details, step-by-step Vercel/Railway deployment, domain/SSL instructions using platform guides.",
            "status": "done",
            "testStrategy": "Follow guide in clean VM to deploy successfully. Verify all ENV vars are comprehensive.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:42:33.071Z"
          },
          {
            "id": 4,
            "title": "Document Development and User Guides",
            "description": "Create development-guide.md and user-guide.md covering local setup, tests, code style, PR process, dashboard usage, and campaign creation.",
            "dependencies": [],
            "details": "development-guide.md: local setup (npm install, env setup), test commands, ESLint/Prettier rules, PR templates. user-guide.md: screenshots of dashboard, step-by-step first campaign, audit results interpretation, FAQ troubleshooting.",
            "status": "done",
            "testStrategy": "Test local setup instructions on new clone. Verify user guide steps work end-to-end.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:49:20.402Z"
          },
          {
            "id": 5,
            "title": "Document API Key Setup and Final Review",
            "description": "Add API key setup instructions to docs and perform comprehensive documentation review.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create section or api-keys.md: Mailgun API key acquisition, Google OAuth Calendar setup, Supabase project creation with RLS policies. Link all docs together. Review for consistency, test all code samples, add changelog template.",
            "status": "done",
            "testStrategy": "Team member review for completeness. Test all external service setups. Validate all links and examples.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T13:51:50.708Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Include architecture diagrams, API schema examples, and step-by-step deployment screenshots.",
        "updatedAt": "2026-02-03T13:51:50.708Z"
      },
      {
        "id": "38",
        "title": "Setup CI/CD Pipeline with GitHub Actions",
        "description": "Configure automated testing, building, and deployment pipeline.",
        "details": "Create .github/workflows/:\n1. ci.yml - Continuous Integration:\n   - Trigger on PR and push to main\n   - Run TypeScript compilation\n   - Run ESLint\n   - Run unit tests with coverage\n   - Run integration tests\n   - Upload coverage report\n   - Fail on coverage drop\n2. e2e.yml - E2E Tests:\n   - Trigger on PR\n   - Spin up test database\n   - Run Playwright tests\n   - Upload test artifacts (screenshots, videos)\n   - Visual regression comparison\n3. deploy-staging.yml - Staging Deployment:\n   - Trigger on merge to main\n   - Build dashboard\n   - Deploy to Vercel preview\n   - Run smoke tests\n4. deploy-production.yml - Production Deployment:\n   - Trigger on release tag\n   - Build with production env\n   - Deploy to Vercel production\n   - Run health checks\n   - Notify on success/failure\n5. Database migrations:\n   - Run Supabase migrations on deploy\n   - Rollback on failure\n6. Security scanning:\n   - npm audit for vulnerabilities\n   - CodeQL analysis",
        "testStrategy": "Verify all workflows run successfully. Test PR checks block merge on failure. Test deployment creates accessible site.",
        "priority": "medium",
        "dependencies": [
          "34",
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CI Workflow (ci.yml)",
            "description": "Implement continuous integration workflow with TypeScript compilation, linting, unit/integration tests, coverage upload, and failure on coverage drop.",
            "dependencies": [],
            "details": "Create .github/workflows/ci.yml with triggers on PR and push to main. Steps: checkout, setup Node, npm install, tsc compile, ESLint, unit tests with coverage (e.g., Jest), integration tests, upload coverage to Codecov or similar, check coverage threshold using if condition or action.",
            "status": "pending",
            "testStrategy": "Trigger workflow via PR/push, verify all steps pass, check coverage report upload, confirm failure when coverage drops below threshold.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create E2E Tests Workflow (e2e.yml)",
            "description": "Set up end-to-end testing workflow using Playwright with test database, artifact uploads, and visual regression.",
            "dependencies": [],
            "details": "Create .github/workflows/e2e.yml triggered on PR. Steps: checkout, setup Node, npm install, spin up test DB (Supabase Docker or ephemeral instance), run Playwright tests, upload screenshots/videos as artifacts, integrate visual regression tool like Playwright Visual Comparisons.",
            "status": "pending",
            "testStrategy": "Create test PR, verify DB spins up, tests run completely, artifacts upload successfully, visual diffs detected/reported.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Staging Deployment Workflow",
            "description": "Configure automated staging deployment to Vercel preview on main branch merge with smoke tests.",
            "dependencies": [],
            "details": "Create .github/workflows/deploy-staging.yml triggered on push to main. Steps: checkout, npm install, build dashboard (npm run build), deploy to Vercel using Vercel GitHub Action with preview environment, run smoke tests against preview URL using simple fetch or Playwright.",
            "status": "pending",
            "testStrategy": "Merge to main, verify Vercel preview deploys, smoke tests pass confirming site accessibility.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Production Deployment Workflow",
            "description": "Set up production deployment triggered by release tags with health checks and notifications.",
            "dependencies": [],
            "details": "Create .github/workflows/deploy-production.yml triggered on release tags. Steps: checkout specific tag, npm install, build with production env vars, deploy to Vercel production via GitHub Action, run health checks (API endpoints, DB connectivity), Slack/Discord notification on success/failure using GitHub Action.",
            "status": "pending",
            "testStrategy": "Create release tag, verify production deploy succeeds, health checks pass, notifications sent appropriately.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Security Scanning and DB Migrations",
            "description": "Integrate npm audit, CodeQL analysis, and Supabase migrations with rollback into existing workflows.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update all workflows: add npm audit step, setup CodeQL analysis in ci.yml. For deployments, add Supabase CLI migration step (supabase db push/migrate) with manual approval or auto-rollback on failure using if: failure() conditions.",
            "status": "pending",
            "testStrategy": "Verify security scans run without blocking on PRs, test migration step on deploy with failure scenario to confirm rollback works.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Configure matrix testing, artifact caching, and deployment approval gates.",
        "updatedAt": "2026-02-02T15:05:48.852Z"
      },
      {
        "id": "39",
        "title": "Implement Rate Limiting and Anti-Detection Measures",
        "description": "Add comprehensive rate limiting and stealth measures to prevent blocking and ensure sustainable operation.",
        "details": "Enhance stealth and rate limiting:\n1. Request rate limiting:\n   - MAPS_DELAY_MS = 2000-5000 (random)\n   - AUDIT_DELAY_MS = 1000\n   - EMAILS_PER_HOUR = 100 (respect Mailgun limits)\n   - Implement token bucket algorithm\n2. Maps anti-detection:\n   - Rotate user agents from pool\n   - Randomize viewport slightly\n   - Human-like mouse movements\n   - Random delays between actions (1-3s)\n   - Avoid patterns (don't always scroll same amount)\n3. Browser fingerprint evasion:\n   - Disable webdriver flag\n   - Randomize navigator.plugins\n   - Vary screen dimensions slightly\n   - Use residential proxy rotation (optional)\n4. Session management:\n   - Rotate browser sessions periodically\n   - Clear cookies between searches\n   - Use incognito contexts\n5. Monitoring:\n   - Track request success/failure rates\n   - Alert on elevated block rates\n   - Log blocked requests for analysis\n6. Fallback strategies:\n   - Alternative user agents on block\n   - Longer delays on rate limit\n   - Skip and retry later on persistent block\n7. robots.txt respect:\n   - Check robots.txt before audit\n   - Respect crawl-delay directives",
        "testStrategy": "Test rate limiting enforces delays. Test user agent rotation changes headers. Test block detection identifies blocked responses. Monitor success rate in staging.",
        "priority": "high",
        "dependencies": [
          "15",
          "19"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Token Bucket Rate Limiter",
            "description": "Create a token bucket algorithm class to enforce request limits with configurable capacity, refill rate, and random delays for MAPS (2000-5000ms), AUDIT (1000ms), and EMAILS_PER_HOUR (100).",
            "dependencies": [],
            "details": "Implement TokenBucket class with consume() method using fixed interval refill strategy. Support burst capacity and gradual refill per search results [1][2][4]. Add random delay generation within specified ranges. Integrate with existing request flows.",
            "status": "pending",
            "testStrategy": "Unit tests verify token consumption blocks when empty, refills correctly over time, respects capacity limits, and applies random delays. Integration test with mock requests confirms rate enforcement.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Maps Anti-Detection Measures",
            "description": "Implement user agent rotation, viewport randomization, human-like mouse movements, random action delays (1-3s), and pattern avoidance for Google Maps scraping.",
            "dependencies": [
              1
            ],
            "details": "Create user agent pool rotator, generate random viewport sizes (5%), simulate bezier curve mouse paths, add 1-3s jittered delays between actions, vary scroll amounts randomly. Use Puppeteer stealth plugins where applicable.",
            "status": "pending",
            "testStrategy": "Visual regression tests confirm varied behaviors across runs. Log analysis verifies delay distributions and UA rotation. Mock browser tests validate mouse movement realism.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Browser Fingerprint Evasion",
            "description": "Disable webdriver detection flags, randomize navigator.plugins, vary screen dimensions, and optionally integrate residential proxy rotation for session fingerprinting evasion.",
            "dependencies": [
              1
            ],
            "details": "Use puppeteer-extra-plugin-stealth, override navigator properties with random plugins array, inject random screen.width/height (10px), implement proxy rotation logic with fallback to direct connections.",
            "status": "pending",
            "testStrategy": "Fingerprint test pages (browserleaks.com) verify evasion success rates >95%. Check console for webdriver flags. Validate screen dimension variation across sessions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Session Management and Fallbacks",
            "description": "Add periodic browser session rotation, cookie clearing between searches, incognito contexts, fallback strategies for blocks, and robots.txt compliance checking.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create SessionManager with rotateSession() every N requests, clear cookies/storage between audits, use browser.newContext({ incognito: true }), implement exponential backoff on blocks, parse robots.txt for crawl-delay directives.",
            "status": "pending",
            "testStrategy": "E2E tests confirm session rotation clears identifiers, robots.txt parsing respects delays, fallback delays increase on repeated blocks. Verify incognito isolation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Monitoring and Block Detection",
            "description": "Implement request success/failure tracking, block rate alerting, blocked request logging, and performance metrics dashboard integration.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create RateMonitor with successRate(), block detection via status codes/patterns, threshold-based alerts (email/Slack), structured logging with request metadata. Expose metrics for dashboard consumption.",
            "status": "pending",
            "testStrategy": "Integration tests simulate block responses and verify alerting triggers at 20% threshold. Monitor success rates in staging environment over 1000 requests. Validate log parsing.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Detail token bucket math, stealth plugin configurations, and block detection heuristics.",
        "updatedAt": "2026-01-31T05:04:23.883Z"
      },
      {
        "id": "40",
        "title": "Production Hardening and Security Audit",
        "description": "Final security review, hardening, and preparation for production deployment.",
        "details": "Production security measures:\n1. API security:\n   - Rate limiting on all endpoints\n   - Input validation on all user inputs\n   - SQL injection prevention (parameterized queries)\n   - XSS prevention (content escaping)\n2. Authentication hardening:\n   - Enforce strong passwords\n   - Account lockout after failed attempts\n   - Secure session cookies (httpOnly, secure, sameSite)\n   - CSRF protection\n3. Secrets management:\n   - All secrets in environment variables\n   - No hardcoded credentials in code\n   - Secrets rotation procedure\n   - Audit log for secret access\n4. Database security:\n   - Row Level Security enabled\n   - Least privilege access\n   - Encrypted connections (SSL)\n   - Regular backups\n5. Monitoring and alerting:\n   - Error rate monitoring\n   - Latency monitoring\n   - Security event logging\n   - PagerDuty/Slack alerts\n6. Compliance:\n   - CAN-SPAM compliance for emails\n   - Unsubscribe handling\n   - Data retention policies\n   - Privacy policy and ToS\n7. Penetration testing:\n   - OWASP Top 10 checklist\n   - Dependency vulnerability scan\n   - Security headers verification",
        "testStrategy": "Security audit checklist review. OWASP ZAP scan for vulnerabilities. npm audit passes. Manual penetration testing of auth flows.",
        "priority": "high",
        "dependencies": [
          "33",
          "36",
          "38"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement API Security Measures",
            "description": "Apply rate limiting, input validation, SQL injection prevention, and XSS protection across all endpoints.",
            "dependencies": [],
            "details": "Configure rate limiting using middleware like express-rate-limit. Implement Zod schemas for input validation on all user inputs. Ensure all database queries use parameterized queries with Supabase. Escape user-generated content in templates to prevent XSS.\n<info added on 2026-02-03T03:15:34.194Z>\nSecurity audit findings: Completed codebase review. Found good practices: Zod validation, RLS enabled on all tables, Supabase auth, environment variable management. Critical gaps: No rate limiting, no CORS config, no security headers, no password strength enforcement, no CSRF protection, missing account lockout, no API input validation middleware, placeholder API keys in .mcp.json. Address gaps by: 1) Adding express-rate-limit middleware to app entry point; 2) Configuring CORS with allowed origins in Supabase integration; 3) Implementing helmet.js for security headers; 4) Extending Supabase auth with password strength Zod schema in login/signup; 5) Adding CSRF tokens via csurf middleware or Supabase session checks; 6) Implementing account lockout logic in AuthContext with failed attempt tracking; 7) Creating global Zod validation middleware for API routes; 8) Removing placeholder keys from .mcp.json and using env vars.\n</info added on 2026-02-03T03:15:34.194Z>",
            "status": "in-progress",
            "testStrategy": "Unit tests for validation schemas. OWASP ZAP scan for injection/XSS vulnerabilities. Load test endpoints to verify rate limiting triggers RateLimitError.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T03:17:36.815Z"
          },
          {
            "id": 2,
            "title": "Harden Authentication Mechanisms",
            "description": "Enforce strong passwords, account lockout, secure session cookies, and CSRF protection.",
            "dependencies": [
              1
            ],
            "details": "Update password validation to require min 12 chars, uppercase, numbers, symbols. Implement lockout after 5 failed attempts. Set session cookies with httpOnly, secure, SameSite=Strict. Add CSRF tokens to all forms using csurf or similar.",
            "status": "pending",
            "testStrategy": "Test failed login attempts trigger lockout. Verify cookie flags in browser dev tools. Test CSRF by submitting forms without tokens.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Establish Secrets Management Practices",
            "description": "Move all secrets to environment variables, remove hardcoded creds, define rotation procedure, and add access logging.",
            "dependencies": [
              3
            ],
            "details": "Audit codebase for hardcoded secrets and replace with process.env refs validated in config. Document rotation procedure in README. Integrate secret access logging to Supabase audit logs. Use AppConfig from Task 3 for validation.",
            "status": "pending",
            "testStrategy": "npm audit and grep search for hardcoded secrets. Test app startup with missing env vars throws config error. Verify logs capture secret access.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Secure Database Configuration and Compliance",
            "description": "Enable Row Level Security, least privilege, SSL connections, backups, CAN-SPAM compliance, and data retention.",
            "dependencies": [
              2
            ],
            "details": "Configure Supabase RLS policies for all tables. Set service role key with minimal privileges. Enable SSL for all DB connections. Schedule automated backups. Implement email unsubscribe endpoints and retention policies per privacy policy.",
            "status": "pending",
            "testStrategy": "Test RLS blocks unauthorized row access. Verify SSL with connection tests. Confirm unsubscribe reduces email lists. Audit data deletion after retention period.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Setup Monitoring, Penetration Testing, and Final Audit",
            "description": "Implement monitoring/alerting, run OWASP checklist, dependency scans, security headers, and produce audit report.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Integrate Sentry/Prometheus for error/latency monitoring with PagerDuty/Slack alerts. Run OWASP ZAP scan, npm audit, verify headers (CSP, HSTS). Document findings and remediation status in audit report.",
            "status": "pending",
            "testStrategy": "Simulate errors to test alerts. Full OWASP Top 10 manual checklist verification. npm audit produces zero high vulnerabilities. E2E pen testing of auth and API flows.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Document security checklist, penetration test scenarios, and compliance verification procedures.",
        "updatedAt": "2026-02-03T04:24:21.221Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-03T13:58:08.791Z",
      "taskCount": 40,
      "completedCount": 40,
      "tags": [
        "master"
      ]
    }
  }
}